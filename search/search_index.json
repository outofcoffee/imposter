{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":""},{"location":"#welcome","title":"Welcome","text":"<p>Imposter is a mock server for REST APIs, OpenAPI (and Swagger) specifications, SOAP web services (and WSDL files), Salesforce and HBase APIs.</p> <ul> <li>Run standalone mock servers in Docker, Kubernetes, AWS Lambda or on the JVM.</li> <li>Embed mocks within your tests (JVM or Node.js) to remove external dependencies.</li> <li>Script dynamic responses using JavaScript, Groovy or Java.</li> <li>Capture data from requests, then store it or return a templated response.</li> <li>Proxy an existing endpoint to replay its responses as a mock.</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>To begin, check out the Getting started guide. See the Core concepts section below, or read a product summary.</p>"},{"location":"#core-concepts","title":"Core concepts","text":"<ul> <li>Getting started</li> <li>Configuration guide</li> <li>Response templates</li> <li>Scripting</li> <li>Security</li> <li>Steps</li> </ul>"},{"location":"#developing-mocks","title":"Developing mocks","text":"<ul> <li>Advanced request matching</li> <li>Interceptors</li> <li>OpenAPI validation</li> <li>Template queries</li> <li>Directory-based responses</li> <li>Performance simulation</li> <li>Failure simulation</li> <li>Generating fake data</li> <li>CORS</li> <li>JavaScript scripting tips</li> <li>Groovy scripting tips</li> <li>JavaScript compatibility</li> <li>Examples</li> </ul>"},{"location":"#data-capture-and-storage","title":"Data capture and storage","text":"<ul> <li>Data capture</li> <li>Stores</li> <li>GraphQL</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Configuration guide</li> <li>Configuration location</li> <li>Scaffolding configuration</li> <li>Environment variables</li> <li>Proxy an existing endpoint</li> <li>Recursive configuration discovery</li> <li>Bundling configuration</li> </ul>"},{"location":"#run-and-deploy","title":"Run and deploy","text":"<ul> <li>Command line (CLI)</li> <li>Docker</li> <li>AWS Lambda</li> <li>Java JAR file</li> <li>Deployment patterns</li> <li>Running in GitHub Actions</li> </ul>"},{"location":"#operational-topics","title":"Operational topics","text":"<ul> <li>Metrics, health, logs and telemetry</li> <li>Performance tuning</li> <li>Benchmarks</li> <li>TLS/SSL</li> </ul>"},{"location":"#mock-types","title":"Mock types","text":"<p>Imposter provides specialised mocks for the following scenarios:</p> <ul> <li>OpenAPI - Support for OpenAPI (and Swagger) API specifications.</li> <li>REST - Mocks RESTful or plain HTTP APIs.</li> <li>SOAP - Support for SOAP web services (and WSDL files).</li> <li>HBase - Basic HBase mock implementation.</li> <li>SFDC (Salesforce) - Basic Salesforce mock implementation.</li> <li>WireMock - Support for WireMock mappings files.</li> </ul>"},{"location":"#learn-more","title":"Learn more","text":""},{"location":"#other","title":"Other","text":"<ul> <li>Plugins</li> <li>Features</li> <li>Tips and tricks</li> <li>Usage</li> </ul>"},{"location":"#product","title":"Product","text":"<ul> <li>Summary</li> <li>Product home</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>Mocking APIs with OpenAPI and Imposter</li> <li>Mocking REST APIs with Imposter</li> <li>Mocking SOAP web services with Imposter</li> </ul>"},{"location":"#developers","title":"Developers","text":"<ul> <li>GitHub</li> <li>Roadmap</li> <li>Build</li> </ul>"},{"location":"benchmarks/","title":"Performance benchmarks","text":"<p>Imposter supports hundreds to thousands of requests per second, on a single CPU core and small memory footprint.</p> <p>This section provides representative performance tests, including test set up and configuration.</p> <p>See Performance tuning to learn how to get the most out of Imposter.</p>"},{"location":"benchmarks/#benchmarks","title":"Benchmarks","text":"<p>Test configuration:</p> <ul> <li>1 CPU core</li> <li>256MB RAM</li> <li>Load injector: Apache Bench 2.3</li> </ul> <p>See Benchmark set up section for full details.</p>"},{"location":"benchmarks/#warm-up","title":"Warm-up","text":"<p>5 x 2 second load, at concurrency of 50</p>"},{"location":"benchmarks/#scenario-1-static-configuration-driven","title":"Scenario 1: Static, configuration-driven","text":"Threads Requests/sec HTTP Keep-alive 50 1075 Disabled 100 1399 Disabled 200 1733 Disabled 200 2712 Enabled"},{"location":"benchmarks/#scenario-2-conditional-configuration-driven","title":"Scenario 2: Conditional, configuration-driven","text":"Threads Requests/sec HTTP Keep-alive 50 939 Disabled 100 1216 Disabled 200 1619 Disabled 200 2027 Enabled"},{"location":"benchmarks/#scenario-3-dynamic-script-driven","title":"Scenario 3: Dynamic, script-driven","text":"Threads Requests/sec HTTP Keep-alive 50 669 Disabled 100 733 Disabled 200 869 Disabled 200 1028 Enabled"},{"location":"benchmarks/#benchmark-set-up","title":"Benchmark set up","text":"<p>Configuration and commands to allow benchmarks to be independently reproduced.</p>"},{"location":"benchmarks/#scenarios","title":"Scenarios","text":"<ul> <li>Scenario 1: Static, configuration-driven: examples/rest/simple</li> <li>Scenario 2: Conditional, configuration-driven: examples/rest/conditional-config</li> <li>Scenario 3: Dynamic, script-driven: examples/rest/conditional-scripted</li> </ul>"},{"location":"benchmarks/#start-command","title":"Start command","text":"<pre><code> docker run --rm -it \\\n    -v /path/to/config:/opt/imposter/config \\\n    -p 8080:8080 \\\n    -e IMPOSTER_LOG_LEVEL=info \\\n    --cpus=1 \\\n    --memory=256m \\\n    outofcoffee/imposter:3.42.0\n</code></pre> <p>Notes:</p> <ul> <li>limits to 1 CPU core</li> <li>limits to 256 MB RAM</li> </ul>"},{"location":"benchmarks/#warmup-command","title":"Warmup command","text":"<pre><code>for i in {1..10}; do ab -t 2 -c 50 http://localhost:8080/example ; sleep 5 ; done\n</code></pre> <p>Notes:</p> <ul> <li>actual URL depends on the scenario (see above)</li> </ul>"},{"location":"benchmarks/#benchmark-command","title":"Benchmark command","text":"<pre><code> ab -n 2000 -c 200 http://localhost:8080/example\n</code></pre> <p>Notes:</p> <ul> <li>actual URL depends on the scenario (see above)</li> <li>concurrency value (<code>-c</code> flag) depends on test case (see above)</li> </ul>"},{"location":"build/","title":"Build","text":""},{"location":"build/#hacking-locally","title":"Hacking locally","text":"<p>You can build and run locally using the <code>dev-current.sh</code> convenience script. This will start Imposter in debug mode, with the debug port running on 8000.</p> <p>Build and run with Docker:</p> <pre><code>./scripts/dev-current.sh -m docker\n</code></pre> <p>Build and run with local JVM:</p> <pre><code>./scripts/dev-current.sh -m java\n</code></pre> <p>More complete example specifying plugin and config directory:</p> <pre><code> ./scripts/dev-current.sh -m docker -p rest -c $PWD/examples/rest/multiple\n</code></pre> <p>See the README for more details about using this script.</p>"},{"location":"build/#local-build","title":"Local build","text":"<p>If you don't want to use the convenience script, then you can follow these steps.</p>"},{"location":"build/#prerequisites","title":"Prerequisites","text":"<ul> <li>JDK 11</li> </ul>"},{"location":"build/#steps","title":"Steps","text":"<p>For distribution, Imposter is built as an all-in-one JAR file. This is available as a Docker image, as well as in raw form.</p> <p>To get started with the examples here, first run:</p> <pre><code>./gradlew clean dist\n</code></pre> <p>The JAR is created under the <code>distro/all/build/libs</code> directory.</p> <p>If, instead, you wanted to compile the JAR without embedded dependencies, use:</p> <pre><code>./gradlew clean build\n</code></pre>"},{"location":"build/#tests","title":"Tests","text":"<p>If you want to run tests:</p> <pre><code>./gradlew clean test\n</code></pre>"},{"location":"build/#docker-containers","title":"Docker containers","text":"<p>Build the Docker containers with:</p> <pre><code>./scripts/docker-build.sh\n</code></pre>"},{"location":"build/#extending-to-build-a-custom-application","title":"Extending to build a custom application","text":"<p>To extend Imposter and build a custom application see this section.</p>"},{"location":"bundle/","title":"Bundle configuration","text":"<p>Bundling is the inclusion of mock configuration alongside the Imposter binaries in a deployment package, such as a container image or Lambda ZIP file.</p> <p>This keeps all elements of the mock in a single package, simplifying deployment and distribution of your mocks.</p>"},{"location":"bundle/#advantages","title":"Advantages","text":"<ul> <li>Engine and configuration can be deployed in a single step</li> <li>Engine and configuration don't require an external mechanism to keep them in sync</li> <li>Engine does not have to be restarted by an external mechanism to pick up new configuration</li> </ul>"},{"location":"bundle/#disadvantages","title":"Disadvantages","text":"<ul> <li>Engine is also deployed when updating configuration</li> <li>Combined deployment package is larger than deploying configuration alone</li> </ul>"},{"location":"bundle/#how-to-bundle-configuration","title":"How to bundle configuration","text":"<p>There are different ways to bundle configuration, depending on the deployment target.</p>"},{"location":"bundle/#aws-lambda-bundles","title":"AWS Lambda bundles","text":"<p>When deploying to AWS Lambda, you can bundle the configuration files into the Lambda ZIP file.</p>"},{"location":"bundle/#creating-a-bundle-for-lambda-automated","title":"Creating a bundle for Lambda (automated)","text":"<p>You can create a bundle using the CLI using the <code>imposter bundle</code> command.</p> <pre><code>$ imposter bundle -t awslambda -o bundle.zip\n\ncreating awslambda bundle /users/person/mock using version 3.32.0\ndownloading https://github.com/imposter-project/imposter-jvm-engine/releases/download/v3.32.0/imposter-awslambda.zip\nbundling 3 files from workspace\ncreated deployment package\ncreated awslambda bundle: /users/person/mock/bundle.zip\n</code></pre> <p>The bundle file (<code>bundle.zip</code> in this example), can be deployed to AWS Lambda as normal.</p>"},{"location":"bundle/#creating-a-bundle-for-lambda-manual","title":"Creating a bundle for Lambda (manual)","text":"<p>If you do not want to use the CLI, you can create a bundle using standard <code>zip</code> tools.</p> <p>Download the latest <code>imposter-awslambda.zip</code> distribution from the Releases page.</p> <p>Let's assume your configuration sits in a directory called <code>config</code>.</p> <pre><code>$ ls -l\ndrwxr-xr-x  5 person  wheel  160B 16 Nov 13:12 config\n-rw-r--r--  1 person  staff  20M  16 Nov 13:12 imposter-awslambda.zip\n</code></pre> <p>Add the config to the ZIP file:</p> <pre><code>$ zip -ur imposter-awslambda.zip config\n\n  adding: config/ (stored 0%)\n  adding: config/mock-config.yaml (deflated 19%)\n  adding: config/response.json (stored 0%)\n  adding: config/mock.txt (deflated 22%)\n</code></pre> <p>Note This command updates the existing ZIP file.</p> <p>The <code>imposter-awslambda.zip</code> file can be deployed to AWS Lambda as normal.</p>"},{"location":"bundle/#docker-bundles","title":"Docker bundles","text":"<p>When deploying using containers, you can add the configuration files into the container image itself.</p>"},{"location":"bundle/#creating-a-container-image-bundle-automated","title":"Creating a container image bundle (automated)","text":"<p>You can create a bundle using the CLI using the <code>imposter bundle</code> command.</p> <p>Let's assume your configuration sits in a file called <code>some-config.yaml</code>:</p> <pre><code>$ ls\nsome-config.yaml\n</code></pre> <p>Bundle it:</p> <pre><code>$ imposter bundle -t docker -o example/mock:v1\nDEBU[0000] creating docker bundle /users/person/mock using version 3.33.3\nDEBU[0000] engine image '3.33.3' already present\n...\nSuccessfully built c791e6281b26\nSuccessfully tagged example/mock:v1\nINFO[0000] build process completed\nINFO[0000] created docker bundle: example/mock:v1\n</code></pre> <p>This command created a container image called <code>example/mock:v1</code> containing the configuration file and the Imposter mock engine.</p> <p>This is a standard Docker container image, so you can push it to a registry and run it anywhere Docker runs.</p> <p>Note The container image in this example is tagged as <code>example/mock:v1</code> but you can specify any valid container name as the <code>-o NAME</code> option. </p> <p>Run the container:</p> <pre><code>$ docker run -it -p 8080:8080 example/mock:v1\n...\nLoading configuration file: ConfigReference(file=/opt/imposter/config/some-config.yaml, configRoot=/opt/imposter/config)\nMock engine up and running on http://localhost:8080\n</code></pre> <p>The mock server is running at http://localhost:8080.</p>"},{"location":"bundle/#creating-a-container-image-bundle-manual","title":"Creating a container image bundle (manual)","text":"<p>Let's assume your configuration sits in a directory called <code>config</code>.</p> <p>Here is an example Dockerfile:</p> <pre><code>FROM outofcoffee/imposter\n\n# your custom config\nCOPY config /opt/imposter/config\n</code></pre> <p>Build it:</p> <pre><code>$ docker build --tag example/mocks .\n</code></pre> <p>The container image (<code>example/mocks</code> in this example), can be run with Docker as normal.</p> <pre><code>$ docker run --rm -it -p 8080:8080 example/mocks\n</code></pre> <p>This is a standard Docker container image, so you can push it to a registry and run it anywhere Docker runs.</p> <p>See the Docker example project for a working example.</p>"},{"location":"config_discovery/","title":"Recursive configuration discovery","text":"<p>By default, configuration files with the suffix <code>-config.json</code>, <code>-config.yaml</code> or <code>-config.yml</code> are loaded from the configuration directory.</p>"},{"location":"config_discovery/#recursively-loading-configuration-files","title":"Recursively loading configuration files","text":"<p>By default, Imposter reads configuration files within the configuration directories, but not their subdirectories.</p> <p>To also load configuration files within subdirectories, set the following environment variable:</p> <pre><code>IMPOSTER_CONFIG_SCAN_RECURSIVE=\"true\"\n</code></pre> <p>This will load all configuration files from the configuration directory and all subdirectories.</p>"},{"location":"config_discovery/#recursive-config-scan-performance","title":"Recursive config scan performance","text":"<p>Warning When using recursive scan for configuration, directories with many files or subdirectories (such as <code>node_modules</code>) can significantly slow down Imposter startup time.</p> <p>Typically, you would not store your Imposter configuration files within a directory such as <code>node_modules</code>, so it is safe to ignore such paths when scanning for configuration files. The mechanism for this is a file named <code>.imposterignore</code></p> <p>When this file is placed in the root of a configuration directory, you can customise which files/directories to ignore by exact match. For example:</p> <pre><code># By default, ignore the following files and directories\n# when searching for config files\n\n.git\n.idea\n.svn\nnode_modules\n</code></pre> <p>If no <code>.imposterignore</code> file is present in any configuration directory, a default ignore file is used containing sensible defaults.</p>"},{"location":"config_discovery/#prefixing-all-paths-using-the-basepath-property","title":"Prefixing all paths using the <code>basePath</code> property","text":"<p>It is possible to prefix all paths in a configuration file using the <code>basePath</code> property.</p> <p>This can be set at the root of the configuration file and applies to all <code>path</code> properties in that configuration file.</p> <p>Example:</p> <pre><code>plugin: rest\nbasePath: /example\n\nresources:\n- path: /foo\n  method: GET\n  response:\n    content: \"Hello world\"\n\n- path: /bar\n  method: GET\n  response:\n    content: \"Good day\"\n</code></pre> <p>This would result in the resources being accessible at the path: <code>/example/foo</code> and <code>/example/bar</code>, rather than <code>/foo</code> and <code>/bar</code>.</p>"},{"location":"config_discovery/#automatic-base-path-when-using-recursive-configuration-discovery","title":"Automatic base path, when using recursive configuration discovery","text":"<p>When using recursive configuration discovery, you can automatically set the <code>basePath</code> based on the subdirectory path.</p> <p>To enable this behaviour set the environment variable:</p> <pre><code>IMPOSTER_AUTO_BASE_PATH=true\n</code></pre> <p>If the directory structure was as follows:</p> <pre><code>&lt;config root&gt;\n\\-- mock1\n|   \\-- some-config.yaml\n\\-- mock2\n|   \\-- another-config.yaml\n\\-- nested\n    \\-- mock2\n        \\-- another-config.yaml\n</code></pre> <p>...then the <code>basePath</code> will be set as follows:</p> <ul> <li>for 'mock1' it would be <code>/mock1</code></li> <li>for 'mock2' it would be <code>/mock2</code></li> <li>for 'mock3' it would be <code>/nested/mock3</code></li> </ul>"},{"location":"config_location/","title":"Configuration location","text":"<p>Imposter can load configuration files from a directory or an S3 bucket.</p> <p>By default, configuration files with the suffix <code>-config.json</code>, <code>-config.yaml</code> or <code>-config.yml</code> are loaded from the configuration directory.</p> <p>This section describes how to load from these sources, depending on how you run Imposter.</p> <p>Also see recursive configuration discovery rules.</p>"},{"location":"config_location/#using-the-cli","title":"Using the CLI","text":""},{"location":"config_location/#directory","title":"Directory","text":"<p>To load configuration files from a directory, pass the path to the directory in the <code>imposter up</code> command:</p> <pre><code>imposter up /path/to/config/dir\n</code></pre> <p>Note If no directory is specified, Imposter will use the current working directory.</p>"},{"location":"config_location/#s3","title":"S3","text":"<p>You can load configuration from an S3 bucket by setting the <code>IMPOSTER_CONFIG_DIR</code> environment variable to the S3 URL, such as:</p> <pre><code>imposter up -e IMPOSTER_CONFIG_DIR=s3://my-bucket/path/to/config/dir \n</code></pre>"},{"location":"config_location/#using-docker","title":"Using Docker","text":""},{"location":"config_location/#directory_1","title":"Directory","text":"<p>To load configuration files from a directory, mount the directory to <code>/opt/imposter/config</code>:</p> <pre><code>docker run -v /path/to/config/dir:/opt/imposter/config outofcoffee/imposter\n</code></pre>"},{"location":"config_location/#s3_1","title":"S3","text":"<p>You can load configuration from an S3 bucket by setting the <code>IMPOSTER_CONFIG_DIR</code> environment variable to the S3 URL, such as:</p> <pre><code>docker run -e IMPOSTER_CONFIG_DIR=s3://my-bucket/path/to/config/dir outofcoffee/imposter\n</code></pre>"},{"location":"config_location/#bundled-configuration","title":"Bundled configuration","text":"<p>See the Bundled Configuration section of the deployment patterns page for more information.</p>"},{"location":"config_location/#using-lambda","title":"Using Lambda","text":""},{"location":"config_location/#s3_2","title":"S3","text":"<p>You can load configuration from an S3 bucket by setting the <code>IMPOSTER_CONFIG_DIR</code> environment variable to the S3 URL, such as:</p> <pre><code>IMPOSTER_CONFIG_DIR=s3://my-bucket/path/to/config/dir\n</code></pre>"},{"location":"config_location/#directory_2","title":"Directory","text":"<p>It is not possible to load configuration files from a directory when using Lambda. Instead, bundle configuration files into a ZIP file.</p>"},{"location":"config_location/#bundled-configuration_1","title":"Bundled configuration","text":"<p>To do this, use the <code>imposter bundle</code> CLI command:</p> <pre><code>imposter bundle -t awslambda /path/to/config/dir\n</code></pre> <p>This will create a ZIP file in the current working directory, which can be deployed to Lambda. The bundle contains both the Imposter engine and the configuration files.</p> <p>See the Bundled Configuration section of the deployment patterns page for more information.</p>"},{"location":"config_location/#using-the-jar","title":"Using the JAR","text":""},{"location":"config_location/#directory_3","title":"Directory","text":"<p>To load configuration files from a directory, pass the path to the directory in the <code>--configDir</code> flag:</p> <pre><code>java -jar imposter.jar --configDir=/path/to/config/dir\n</code></pre>"},{"location":"config_location/#s3_3","title":"S3","text":"<p>You can load configuration from an S3 bucket by passing the S3 URL in the <code>--configDir</code> flag:</p> <pre><code>java -jar imposter.jar --configDir=s3://my-bucket/path/to/config/dir\n</code></pre>"},{"location":"configuration/","title":"Configuration guide","text":"<p>Read this section to learn how to configure Imposter.</p> <p>You can get Imposter to create configuration files for you, based on an existing endpoint or OpenAPI specification. If you don't have either of these, it's easy to create the configuration using the following instructions. </p>"},{"location":"configuration/#basics","title":"Basics","text":"<p>Imposter configuration files are in YAML or JSON format. They must be named with a <code>-config.yaml</code> or <code>-config.json</code> suffix. For example: <code>mymock-config.yaml</code>.</p> <p>Here is an example configuration file:</p> <pre><code># simple-example-config.yaml\n---\nplugin: rest\npath: \"/example\"\nresponse:\n  file: example-data.json\n</code></pre> <p>Or, in JSON format:</p> <pre><code>{\n  \"plugin\": \"rest\",\n  \"path\": \"/example\",\n  \"response\": {\n    \"file\": \"example-data.json\"\n  }\n}\n</code></pre> <p>Note: You must specify the plugin to use in the configuration file. See the list of plugins for possible values.</p>"},{"location":"configuration/#returning-data","title":"Returning data","text":"<p>You can control the data Imposter sends back using response files. The response file is used by the active plugin to generate a response. For example, the REST plugin might return the content of the file unmodified, whereas the HBase and SFDC plugins use the response file to generate responses that mimic their respective systems.</p> <p>Response files can be named anything you like; their path is resolved relative to the configuration file.</p>"},{"location":"configuration/#simple-static-responses","title":"Simple, static responses","text":"<p>For simple scenarios, use the <code>file</code> property within the <code>response</code> object in your configuration.</p> <p>In the example above, we are using a static response file (<code>example-data.json</code>) containing the following:</p> <pre><code>{\n  \"hello\": \"world\"\n}\n</code></pre> <p>Using the configuration above, if we were to send an HTTP request to the <code>/example</code> path defined in the configuration file, we would see:</p> <pre><code>HTTP GET http://localhost:8080/example\n...\nHTTP/1.1 200 OK\n...\n{\n  \"hello\": \"world\"\n}\n</code></pre> <p>The plugin has returned the contents of the <code>file</code> in the HTTP response.</p> <p>Your response files can also be templated - that is, contain placeholders substituted at runtime. See templates for more information.</p>"},{"location":"configuration/#response-configuration-options","title":"Response configuration options","text":"<p>You can specify other properties of the response, such as status code and headers. Here is a more complete example:</p>"},{"location":"configuration/#single-resource-example","title":"Single resource example","text":"<pre><code># single-response-config.yaml\n---\nplugin: rest\npath: \"/example\"\nmethod: POST\ncontentType: \"application/json\"\nresponse:\n  file: data.json\n  statusCode: 201\n  headers:\n    X-Custom-Header: foo\n</code></pre> <p>Some highlights:</p> <ul> <li>This endpoint will only be accessible via the <code>POST</code> HTTP method</li> <li>We've indicated that status code 201 should be returned</li> <li>We've set the content type of the response to JSON</li> <li>A custom header will be returned</li> </ul>"},{"location":"configuration/#multiple-resources-example","title":"Multiple resources example","text":"<p>The OpenAPI plugin, SOAP plugin and REST plugin allow you to specify multiple resources, using the <code>resources</code> array. Each resource can have its own path, method, response behaviour etc.</p> <pre><code># multi-response-config.yaml\n---\nplugin: rest\nresources:\n- path: \"/example1\"\n  contentType: \"application/json\"\n  method: GET\n  response:\n    file: data1.json\n    statusCode: 200\n    headers:\n      X-Custom-Header: foo\n\n- path: \"/example2\"\n  contentType: \"text/plain\"\n  method: POST\n  response:\n    statusCode: 201\n    headers:\n      X-Custom-Header: bar\n    content: |\n      This is some\n      multiline response data.\n</code></pre>"},{"location":"configuration/#default-response-configuration","title":"Default response configuration","text":"<p>In some cases, you might want to define default response configuration, e.g. a header that should be sent in all responses. To do this, set the <code>defaultsFromRootResponse: true</code> option, as follows:</p> <pre><code>plugin: rest\n\n# root response config should be inherited\ndefaultsFromRootResponse: true\n\nresponse:\n  headers:\n    X-Always-Present: Yes\n\nresources:\n- method: GET\n  path: /example1\n  response:\n    content: \"Hello world\"\n\n- method: GET\n  path: /example2\n  response:\n    content: \"Lorem ipsum\"\n</code></pre> <p>In this example, responses to both <code>/example1</code> and <code>/example2</code> will have the header <code>X-Always-Present: Yes</code> set, as it is inherited from the root configuration.</p> <p>See default-response-config for an example.</p>"},{"location":"configuration/#default-response-values","title":"Default response values","text":"<p>If unset by configuration or a script, the default values for response configuration fields are as follows:</p> Field Plugin(s) Type Default Example <code>contentType</code> all String <code>application/json</code>, or determined from static file <code>text/plain</code> <code>response.statusCode</code> openapi, rest Integer (HTTP status) <code>200</code> <code>201</code> <code>response.content</code> openapi, rest String empty <code>hello world</code> <code>response.file</code> all String empty <code>data.json</code> <code>response.headers</code> openapi, rest Map of String:String empty <code>{ \"X-Custom-Header\": \"value\" }</code>"},{"location":"configuration/#conditional-responses","title":"Conditional responses","text":"<p>You can make Imposter respond with different values based on certain properties of the request.</p> <p>Conditional responses can be set in your configuration file, or using the script engine.</p> <p>For information about the script engine, see the Scripting documentation.</p> <p>Using the configuration file approach, it is possible to configure different response behaviours based on the following request attributes:</p> Field Plugin(s) Type Example <code>path</code> all String <code>/example/path</code> <code>method</code> openapi, rest String (HTTP method) <code>POST</code> <code>pathParams</code> openapi, rest Map of String:String <code>{ \"productCode\": \"abc\" }</code> <code>queryParams</code> openapi, rest Map of String:String <code>{ \"limit\": \"10\" }</code> <code>formParams</code> openapi, rest Map of String:String <code>{ \"user\": \"alice\" }</code> <code>requestHeaders</code> openapi, rest Map of String:String <code>{ \"User-Agent\": \"curl\" }</code> <code>requestBody</code> openapi, rest Request body matching configuration See advanced matching <p>Here is an example showing a range of fields:</p> <pre><code>plugin: openapi\nspecFile: apispec.yaml\n\nresources:\n  # handles GET /pets?page=1\n  - path: \"/pets\"\n    method: GET\n    queryParams:\n      page: 1\n    response:\n      statusCode: 200\n\n  # handles GET /pets/10\n  - path: \"/pets/{petId}\"\n    method: GET\n    pathParams:\n      petId: 10\n    response:\n      statusCode: 401\n      content: \"You do not have permission to view this pet.\"\n\n  # handles PUT /pets/{petId} with a request header 'X-Pet-Username: foo'\n  - path: \"/pets/{petId}\"\n    method: PUT\n    requestHeaders:\n      X-Pet-Username: foo\n    response:\n      statusCode: 409\n      content: \"Username already exists.\"\n</code></pre>"},{"location":"configuration/#matching-the-request-body","title":"Matching the request body","text":"<p>You can also match resources based on the request body (both JSON and XML are supported). See advanced matching for details.</p>"},{"location":"configuration/#matching-paths-with-a-trailing-wildcard","title":"Matching paths with a trailing wildcard","text":"<p>You can match paths with a trailing wildcard (<code>*</code>) to match multiple paths. For example:</p> <pre><code>plugin: rest\n\nresources:\n  - path: \"/example/*\"\n    method: GET\n    response:\n      statusCode: 200\n      content: \"This is a wildcard response.\"\n</code></pre> <p>In this example, the response will be returned for any path starting with <code>/example/</code>.</p>"},{"location":"configuration/#capturing-data","title":"Capturing data","text":"<p>Imposter allows you to capture elements of the request. You can use these elements in a response template, a script or add them to a store for later use.</p> <p>See data capture for more information.</p>"},{"location":"configuration/#environment-variables","title":"Environment variables","text":"<p>You can use environment variables as placeholders in plugin configuration files.</p> <pre><code># A plugin configuration using an environment variable.\n---\nplugin: rest\npath: /example\nresponse:\n  content: \"${env.EXAMPLE_RESPONSE}\"\n</code></pre> <p>Here the environment variable <code>EXAMPLE_RESPONSE</code> will be substituted into the configuration. For example, if the variable was set as follows:</p> <pre><code>EXAMPLE_RESPONSE=\"Hello\"\n</code></pre> <p>...then the static data <code>Hello</code> will be returned.</p> <p>You can use environment variables anywhere within your configuration files, for example, in the <code>security</code> section to avoid including secrets in your configuration files. </p>"},{"location":"configuration/#default-environment-variable-values","title":"Default environment variable values","text":"<p>You can use the following syntax to set defaults for environment variables:</p> <pre><code>${env.NAME_OF_VAR:-defaultValue}\n</code></pre> <p>For example:</p> <pre><code>${env.MY_VAR:-foo}\n</code></pre> <p>This would resolve to the value <code>foo</code> if the <code>MY_VAR</code> environment variable was empty or missing.</p>"},{"location":"configuration/#security","title":"Security","text":"<p>Imposter can require specific header values to authenticate incoming HTTP requests. Read about how to do this.</p>"},{"location":"configuration/#config-file-discovery","title":"Config file discovery","text":"<p>By default, Imposter reads configuration files within the configuration directories, but not their subdirectories.</p> <p>To also load configuration files within subdirectories, set the following environment variable:</p> <pre><code>IMPOSTER_CONFIG_SCAN_RECURSIVE=\"true\"\n</code></pre> <p>See the Configuration discovery documentation for more information.</p>"},{"location":"configuration/#scripted-responses-advanced","title":"Scripted responses (advanced)","text":"<p>For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts.</p> <p>See the Scripting section for more information.</p>"},{"location":"configuration/#resource-matching-performance","title":"Resource matching performance","text":"<p>Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance.</p>"},{"location":"cors/","title":"CORS","text":"<p>Imposter supports CORS (Cross-Origin Resource Sharing), which is a mechanism that allows a web page to make a request to a server in a different domain. This is useful for web applications that are hosted on a different domain to the mock endpoint they are consuming.</p> <p>To configure CORS, add the following to your configuration:</p> <pre><code>cors:\n  allowOrigins: all\n</code></pre> <p>Warning This will allow all origins to make requests to the mock endpoint. This is not recommended for production use.</p>"},{"location":"cors/#specifying-allowed-origins","title":"Specifying allowed origins","text":"<p>You can specify the allowed origins using the <code>allowOrigins</code> property. This is a list of strings, where each string is a domain or subdomain that is allowed to make requests to the mock endpoint.</p> <pre><code>cors:\n  allowOrigins:\n    - http://localhost:8080\n    - https://www.example.com \n</code></pre>"},{"location":"cors/#special-values","title":"Special values","text":"<p>You can use the following special values for the <code>allowOrigins</code> property:</p> <ul> <li><code>all</code> - allows all origins to make requests to the mock endpoint, echoing the value of the <code>Origin</code> header in the <code>Access-Control-Allow-Origin</code> response header. This effectively disables CORS.</li> <li><code>*</code> - allows all origins to make requests to the mock endpoint, however, specific limitations such as use of <code>Access-Control-Allow-Credentials</code> apply. See here for more information.</li> </ul>"},{"location":"cors/#specifying-allowed-headers","title":"Specifying allowed headers","text":"<p>You can specify the allowed headers using the <code>allowHeaders</code> property. This is a list of strings, where each string is a header that is allowed to be sent in a request to the mock endpoint.</p> <pre><code>cors:\n  allowHeaders:\n    - Content-Type\n    - X-Custom-Header\n</code></pre>"},{"location":"cors/#specifying-allowed-methods","title":"Specifying allowed methods","text":"<p>You can specify the allowed methods using the <code>allowMethods</code> property. This is a list of strings, where each string is an HTTP method that is allowed to be sent in a request to the mock endpoint.</p> <pre><code>cors:\n  allowMethods:\n    - GET\n    - POST\n</code></pre>"},{"location":"cors/#setting-the-max-age","title":"Setting the max age","text":"<p>You can set the max age using the <code>maxAge</code> property. This is an integer value, representing the number of seconds that the browser should cache the CORS preflight response.</p> <pre><code>cors:\n  maxAge: 3600\n</code></pre>"},{"location":"cors/#allowing-credentials","title":"Allowing credentials","text":"<p>You can allow credentials to be sent in a request to the mock endpoint using the <code>allowCredentials</code> property. This is a boolean value.</p> <pre><code>cors:\n  allowCredentials: true\n</code></pre>"},{"location":"cors/#examples","title":"Examples","text":"<ul> <li>cors-automatic</li> </ul>"},{"location":"data_capture/","title":"Capturing request data","text":"<p>Imposter allows you to capture elements of the request. You can use these elements in a response template, a script or add them to a store for later use.</p> <p>It is possible to capture the following elements into a store:</p> <ul> <li>path parameter</li> <li>query parameter</li> <li>request header</li> <li>part or all of the request body (using JsonPath or XPath expression)</li> <li>form parameters</li> </ul>"},{"location":"data_capture/#capture-example","title":"Capture example","text":"<p>Use the <code>capture</code> block of a resource, as follows:</p> <pre><code>resources:\n- path: \"/users/{userName}\"\n  method: PUT\n  capture:\n    user:\n      pathParam: userName\n      store: testStore\n</code></pre> <p>In this example, the value of the path parameter 'userName' is added to the store named 'testStore' as an item named 'user'.</p> <p>For example, the following request:</p> <pre><code>PUT /users/alice\n</code></pre> <p>...would result in the 'testStore' store containing the item 'user' with the value 'alice'.</p> <p>Note that the name of the item is the object key - in the above example it is <code>user</code>. Multiple items can be captured from the same request using different keys:</p> <pre><code>resources:\n- path: \"/users/{userName}\"\n  method: PUT\n  capture:\n    user:\n      pathParam: userName\n      store: testStore\n    agent:\n      requestHeader: User-Agent\n      store: testStore\n</code></pre>"},{"location":"data_capture/#capture-configuration","title":"Capture configuration","text":"<p>The following configuration options are available for a capture:</p> Element Purpose capture block key The name of the item to capture, e.g. <code>user</code>. <code>store</code> The name of the store in which to put the item. <code>pathParam</code> The name of the path parameter to capture. Must reference the resource path, e.g. <code>userId</code> for a path of <code>/users/{userId}</code> <code>queryParam</code> The name of the query parameter to capture. <code>formParam</code> The name of the form parameter to capture. <code>requestHeader</code> The name of the request header to capture. <code>expression</code> A placeholder expression, e.g. <code>${context.request.queryParams.foo}</code> - see Expressions section. <code>const</code> A constant value, e.g. <code>example</code>. <code>phase</code> The point in the request processing lifecycle that capture and persistence will occur. By default this is <code>REQUEST_RECEIVED</code>. See Deferred capture section. <code>requestBody.jsonPath</code> The JsonPath expression to query the JSON body. Only works with JSON request bodies. <code>requestBody.xPath</code> The XPath expression to query the XML body. Only works with XML request bodies. <code>requestBody.xmlNamespaces</code> Map of prefixes to XML namespaces used by the XPath expression."},{"location":"data_capture/#capturing-the-request-body","title":"Capturing the request body","text":"<p>You can capture part or all of the request body using a JsonPath or XPath expression.</p>"},{"location":"data_capture/#jsonpath-example","title":"JsonPath example","text":"<p>For example, if the request body was:</p> <pre><code>{\n  \"name\": \"Alice\",\n  \"address\": {\n    \"street\": \"1 Main Street\",\n    \"postCode\": \"PO5 7CO\"\n  }\n}\n</code></pre> <p>...you could capture the name as follows:</p> <pre><code># part of your configuration file\n\nresources:\n- path: \"/users\"\n  method: POST\n  capture:\n    firstName:\n      store: testStore\n      requestBody:\n        jsonPath: $.name\n</code></pre> <p>In this example, the <code>name</code> property of the body would be stored in the 'firstName' item in the store named 'testStore'.</p>"},{"location":"data_capture/#xpath-example","title":"XPath example","text":"<p>For example, if the request body was:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;env:Envelope xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\n  &lt;env:Header/&gt;\n  &lt;env:Body&gt;\n    &lt;pets:animal xmlns:pets=\"urn:com:example:petstore\"&gt;\n      &lt;pets:name&gt;Fluffy&lt;/pets:name&gt;\n    &lt;/pets:animal&gt;\n  &lt;/env:Body&gt;\n&lt;/env:Envelope&gt;\n</code></pre> <p>...you could capture the value of the <code>pets:name</code> element as follows:</p> <pre><code># part of your configuration file\n\nresources:\n- path: \"/users\"\n  method: POST\n  capture:\n    petName:\n      store: testStore\n      requestBody:\n        xPath: \"/env:Envelope/env:Body/pets:animal/pets:name\"\n        xmlNamespaces:\n          env: \"http://schemas.xmlsoap.org/soap/envelope/\"\n          pets: \"urn:com:example:petstore\"\n</code></pre> <p>In this example, the value of the <code>pets:name</code> element in the body would be stored in the 'petName' item in the store named 'testStore'.</p> <p>Note: although this example uses a SOAP envelope, any valid XML body can be captured.</p>"},{"location":"data_capture/#expressions","title":"Expressions","text":"<p>You can use an expression in a key name or value.</p> <p>For example:</p> <pre><code>${context.request.headers.Correlation-ID}\n</code></pre> <p>Composite expressions are also supported:</p> <pre><code>example_${context.request.headers.Correlation-ID}_${context.request.headers.User-Agent}\n</code></pre> <p>Note the mix of placeholders, like <code>${context.request.headers.Correlation-ID}</code>, and plain text in this example.</p> <p>The following expressions are supported:</p> Expression format Example Example value <code>context.request.body</code> <code>${context.request.body}</code> <code>{ \"example request\" }</code> <code>context.request.headers.HEADERNAME</code> <code>${context.request.headers.User-Agent}</code> <code>\"Mozilla\"</code> <code>context.request.pathParams.PARAMNAME</code> <code>${context.request.pathParams.account}</code> <code>\"example\"</code> <code>context.request.queryParams.PARAMNAME</code> <code>${context.request.queryParams.page}</code> <code>\"1\"</code> <code>context.response.body</code> <code>${context.response.body}</code> <code>{ \"example response\" }</code> <code>context.response.headers.HEADERNAME</code> <code>${context.response.headers.Content-Type}</code> <code>\"application/json\"</code> <code>datetime.now.iso8601_date</code> <code>${datetime.now.iso8601_date}</code> <code>\"2022-01-20\"</code> <code>datetime.now.iso8601_datetime</code> <code>${datetime.now.iso8601_datetime}</code> <code>\"2022-01-20T14:23:25.737Z\"</code> <code>datetime.now.millis</code> <code>${datetime.now.millis}</code> <code>\"1642688570140\"</code> <code>datetime.now.nanos</code> <code>${datetime.now.nanos}</code> <code>\"30225267785430\"</code> <p>Example:</p> <pre><code># part of your configuration file\n\nresources:\n  - path: \"/people/{team}/{person}\"\n    method: POST\n    capture:\n      personInTeam:\n        expression: \"person=${context.request.pathParams.person},team=${context.request.pathParams.team}\"\n        store: testStore\n</code></pre> <p>For a request such as the following:</p> <pre><code>GET /people/engineering/jane\n</code></pre> <p>The captured item, named <code>personInTeam</code>, would have the value: <code>\"person=jane,team=engineering\"</code></p>"},{"location":"data_capture/#response-expressions","title":"Response expressions","text":"<p>Response expressions, such as <code>${context.response.body}</code>, must use Deferred capture (see Deferred capture section).</p> <p>Example:</p> <pre><code># part of your configuration file\n\nresources:\n- path: \"/example\"\n  method: GET\n  capture:\n    responseBody:\n      expression: \"${context.response.body}\"\n      store: testStore\n      phase: RESPONSE_SENT # this is required for response capture\n</code></pre>"},{"location":"data_capture/#capturing-an-object","title":"Capturing an object","text":"<p>In some scenarios you may wish to capture an object instead of a single value.</p> <p>For example, to capture the address from the example above, use the JsonPath expression <code>$.address</code> - this will result in the entire address object being captured.</p> <p>You can retrieve this object in a script, by accessing the store named 'testStore', or you could use it in a JsonPath placeholder within a template.</p> <p>To capture the whole request body, use the <code>$</code> expression:</p> <pre><code># part of your configuration file\n\nresources:\n- path: \"/users\"\n  method: POST\n  capture:\n    person:\n      store: testStore\n      requestBody:\n        jsonPath: $\n</code></pre> <p>Here the <code>$</code> expression indicates the whole request body object should be captured into the 'person' item.</p>"},{"location":"data_capture/#constant-values","title":"Constant values","text":"<p>In some scenarios, you may wish to capture a constant value.</p> <p>Example:</p> <pre><code>plugin: rest\n\nresources:\n- method: GET\n  path: /test\n  capture:\n    # constant value\n    receivedRequest:\n      store: example\n      const: received\n  response:\n    statusCode: 200\n</code></pre> <p>In the example above, the value <code>received</code> is stored in the 'example' store, with the name 'receivedRequest', when the given endpoint is hit.</p>"},{"location":"data_capture/#dynamic-item-name","title":"Dynamic item name","text":"<p>You do not have to specify a constant value for the item name - you can use a property of the request, such as a query or path parameter, header or body element as the item name.</p> <p>Dynamic item names are useful when you want to capture collections of items, each with their own name derived from the request.</p> <p>Example:</p> <pre><code>plugin: rest\n\nresources:\n- method: PUT\n  path: /users/admins/{userId}\n  capture:\n    adminUser:\n      store: adminUsers\n      expression: \"${datetime.now.iso8601_datetime}\"\n      key:\n        pathParam: userId\n  response:\n    statusCode: 200\n</code></pre> <p>In the example above, an item corresponding to the <code>userId</code> parameter in the request is added to the 'adminUsers' store with the value of the current date/time.</p> <p>Expressions can also be used in the key, for example:</p> <pre><code>plugin: rest\n\nresources:\n- method: PUT\n  path: /users/admins/{userId}\n  capture:\n    adminUser:\n      store: adminUsers\n      expression: \"${datetime.now.iso8601_datetime}\"\n      key:\n        expression: \"${context.request.pathParams.userId}\"\n  response:\n    statusCode: 200\n</code></pre>"},{"location":"data_capture/#request-scoped-store","title":"Request scoped store","text":"<p>There is a special request-scoped store, named <code>request</code>, which is accessible only to the current request. Its contents do not persist beyond the lifecycle of the request.</p> <p>The request scoped store is very useful when you need to capture an item for immediate use, such as in a response template, but you don't need to persist it for later use.</p> <p>Here is an example combining capture and response template:</p> <p>Learn more about response templates.</p> <pre><code># part of your configuration file\n\nresources:\n  - path: \"/users/{userName}\"\n    method: PUT\n    capture:\n      user:\n        pathParam: userName\n        store: request\n    response:\n      file: example-template.json\n      template: true\n</code></pre> <p>Here is the corresponding template file:</p> <pre><code>{\n  \"userName\": \"${stores.request.user}\"\n}\n</code></pre> <p>If you were to make the following request:</p> <pre><code>curl -X PUT http://localhost:8080/users/alice\n</code></pre> <p>...you would receive the following response:</p> <pre><code>{\n  \"userName\": \"alice\"\n}\n</code></pre>"},{"location":"data_capture/#deferred-capture","title":"Deferred capture","text":"<p>If you do not need an item to be persisted to the store immediately, you can choose to defer capture. This will result in the capture and persistence operation being triggered after processing of the current request has completed and the response has been transmitted to the client.</p> <p>Deferring capture has the advantage of improving request throughput, at the cost of persistence occurring after the request has been completed. This trade-off may be useful for particular use cases, such as when writing events to a store for later retrieval, where real-time access is not required.</p>"},{"location":"data_capture/#important-considerations","title":"Important considerations","text":"<p>Deferred items will not be available in the current request (such as in response templates or scripts). Given that the actual persistence operation runs asynchronously, there is no guarantee that it will complete before a subsequent request. When using deferred capture, you should consider carefully any dependent logic or configuration that expects the presence of an item in the store at a particular point in time.</p> <p>Note that deferred capture cannot be used with the request scoped store, since the request store only applies to a single request.</p>"},{"location":"data_capture/#configuring-deferred-capture","title":"Configuring deferred capture","text":"<p>To enable deferred capture for a particular case, set the <code>phase: RESPONSE_SENT</code> property in a capture block, for example:</p> <pre><code># ...other configuration\ncapture:\n  example:\n    expression: \"${context.request.queryParams.example}\"\n    store: testStore\n    phase: RESPONSE_SENT\n</code></pre> <p>The default value of <code>phase</code> is <code>REQUEST_RECEIVED</code></p>"},{"location":"data_capture/#enable-or-disable-capture-configuration","title":"Enable or disable capture configuration","text":"<p>You can selectively enable or disable a capture configuration using the <code>enabled</code> key.</p> <pre><code># ...other configuration\ncapture:\n  firstName:\n    enabled: true\n    store: testStore\n    requestBody:\n      jsonPath: $.name\n</code></pre> <p>The default value of <code>enabled</code> is <code>true</code>.</p> <p>This can be helpful when used in conjunction with environment variable placeholders.</p> <p>For example, if you set the environment variable:</p> <pre><code>NAME_CAPTURE_ENABLED=true\n</code></pre> <p>You can refer to it in your configuration to selectively enable the capture configuration:</p> <pre><code># ...other configuration\ncapture:\n  firstName:\n    enabled: ${env.NAME_CAPTURE_ENABLED}\n    store: testStore\n    requestBody:\n      jsonPath: $.name\n</code></pre>"},{"location":"data_capture/#capture-performance","title":"Capture performance","text":"<p>Data capture incurs overhead on response times, depending on the speed of the store implementation used. If using the in-memory store, the performance impact is lower than using an external store. For store providers backed by external datastores, requests will incur a synchronous write to the store when capturing data.</p> <p>You might consider using deferred capture, which has the advantage of improving request throughput, at the cost of persistence occurring after the request has been completed.</p> <p>Using JsonPath to capture the request body is computationally expensive, as it requires parsing and querying of the request body item rather than just copying a reference.</p>"},{"location":"data_capture/#examples","title":"Examples","text":"<ul> <li>data-capture</li> </ul>"},{"location":"deploy_aws_lambda_cli/","title":"Deploy Imposter to AWS Lambda using the CLI","text":"<p>This section describes how to deploy Imposter as an AWS Lambda function using Imposter CLI.</p>"},{"location":"deploy_aws_lambda_cli/#other-ways-to-deploy-to-lambda","title":"Other ways to deploy to Lambda","text":"<p>You can also deploy Imposter as a Lambda function using the AWS Console, infrastructure as code tools (e.g. Terraform) or a framework such as Serverless.</p>"},{"location":"deploy_aws_lambda_cli/#overview","title":"Overview","text":"<p>The key steps are:</p> <ul> <li>use the Imposter CLI to configure AWS Lambda as the remote deployment target</li> <li>use the Imposter CLI to deploy your configuration (bundled with the Imposter engine) as a Lambda function to the desired AWS region</li> <li>access the Lambda function via a Lambda Function URL</li> </ul>"},{"location":"deploy_aws_lambda_cli/#prerequisites","title":"Prerequisites","text":"<ul> <li>You must have an AWS account and permission to deploy Lambda functions, fetch an IAM role (and optionally create a role if not using an existing role).</li> <li>You must install the Imposter CLI.</li> </ul>"},{"location":"deploy_aws_lambda_cli/#deployment-steps","title":"Deployment steps","text":"<p>For the purposes of this guide, we will assume your working directory contains an Imposter configuration file.</p> <pre><code>$ ls -l\nmock-config.yaml   response.txt\n</code></pre> <p>Note See the Configuration section for more information.</p>"},{"location":"deploy_aws_lambda_cli/#step-1-prepare-your-workspace","title":"Step 1: Prepare your workspace","text":"<p>To begin, create a workspace in this directory:</p> <pre><code>$ imposter workspace new example\n\ncreated workspace 'example'\n</code></pre> <p>A workspace holds configuration, such as details of the remote deployment.</p> <p>You can always check the active workspace by running the <code>imposter workspace show</code> command: <pre><code>$ imposter workspace show\n\nactive workspace: example\n</code></pre></p> <p>You can commit your workspace directory to your source control system (by default, stored under the <code>.imposter</code> subdirectory).</p>"},{"location":"deploy_aws_lambda_cli/#step-2-configure-the-remote","title":"Step 2: Configure the remote","text":"<p>A workspace has a 'remote', where Imposter will be deployed. Set the remote type to AWS Lambda:</p> <pre><code>$ imposter remote set-type awslambda\n\nset remote type to 'awslambda' for remote: example\n</code></pre> <p>Once you have the remote type, you can further configure the remote using the <code>imposter remote config</code> command.</p> <p>For example:</p> <pre><code>$ imposter remote config region=eu-west-1\n</code></pre> <p>Available configuration options are:</p> Property Meaning Default <code>anonAccess</code> Whether to permit anonymous access to the Lambda function URL (<code>true</code> or <code>false</code>) <code>false</code> <code>architecture</code> The lambda architecture, which can be <code>x86_64</code> or <code>arm64</code> <code>x86_64</code> <code>engineVersion</code> The version of the Imposter engine to use, such as <code>3.2.1</code> <code>latest</code> unless set by CLI config file <code>functionName</code> The name of the AWS Lambda function, which must adhere to the AWS function naming rules <code>imposter-&lt;dir name&gt;</code> e.g. <code>imposter-example</code> if config dir name was <code>example</code> <code>iamRoleName</code> The name of a custom IAM Role for the Lambda's execution role. If it doesn't exist, it will be created with this name. <code>ImposterLambdaExecutionRole</code> <code>memory</code> The amount of memory, in megabytes, for the function, such as <code>768</code> <code>768</code> <code>region</code> The AWS Region in which to deploy the function, such as <code>eu-west-1</code> <code>us-east-1</code>"},{"location":"deploy_aws_lambda_cli/#step-3-deploy-to-lambda","title":"Step 3: Deploy to Lambda","text":"<p>Now the remote is configured, deploy the Lambda function:</p> <pre><code>$ imposter remote deploy\n</code></pre> <p>Note The deploy command uses the standard AWS mechanisms for locating credentials. For example, you may have set environment variables, or use the <code>~/.aws/</code> directory, or an instance role if running within EC2.</p> <p>If you receive a credential error, check that:</p> <ul> <li>you have active AWS credentials, e.g. run <code>aws iam get-user</code></li> <li>you have the permissions described in the Prerequisites section</li> </ul> <p>Deployment may take a minute or so, depending on your connection speed, but it should look similar to:</p> <pre><code>deploying workspace 'example' to awslambda remote\nbundling 2 files from workspace\ncreated function: example with arn: arn:aws:lambda:us-east-1:123456789:function:example\ndeployed workspace 'example'\n\nBase URL: https://url-to-invoke-lambda-function\nStatus: https://url-to-invoke-lambda-function/system/status\n</code></pre>"},{"location":"deploy_aws_lambda_cli/#step-4-test-your-lambda","title":"Step 4: Test your Lambda","text":"<p>If all has gone well, you should be able to reach your Lambda function using the status URL:</p> <pre><code>$ curl https://url-to-invoke-lambda-function/system/status\n\n{ \"status\": \"ok\" }\n</code></pre> <p>Note If you receive the following error:</p> <pre><code>{\"Message\":\"Forbidden\"}\n</code></pre> <p>...then you may need to enable anonymous access to the Lambda function URL.</p> <p>To enable anonymous access, run:</p> <pre><code>$ imposter remote config anonAccess=true\n</code></pre> <p>...then redeploy with <code>imposter remote deploy</code></p> <p>You should be able to call your mock endpoints, such as:</p> <pre><code>$ curl https://url-to-invoke-lambda-function/\n\nHello world!\n</code></pre> <p>If you need to change a configuration option, such as memory, use the <code>imposter remote config</code> command and then run <code>imposter remote deploy</code> again.</p> <p>Note If you change the function name of your Lambda after deployment, future deployments will use the new name. This means that the old function with the previous name will still exist. Depending on your use case this may or may not be what you want to happen.</p>"},{"location":"deploy_aws_lambda_cli/#whats-next","title":"What's next","text":"<ul> <li>Learn how to use Imposter with the Configuration guide.</li> </ul>"},{"location":"deploy_aws_lambda_console/","title":"Deploy Imposter to AWS Lambda using the AWS Console","text":"<p>This section describes how to deploy Imposter as an AWS Lambda function using the AWS Console.</p>"},{"location":"deploy_aws_lambda_console/#other-ways-to-deploy-to-lambda","title":"Other ways to deploy to Lambda","text":"<p>You can also deploy Imposter as a Lambda function using the Imposter CLI, infrastructure as code tools (e.g. Terraform) or a framework such as Serverless.</p>"},{"location":"deploy_aws_lambda_console/#overview","title":"Overview","text":"<p>The key steps are:</p> <ul> <li>you upload the Imposter ZIP file and your configuration files to an S3 bucket</li> <li>you create a Lambda function using the ZIP file as the code source</li> <li>you set the environment variables of the function to refer to the configuration path in S3</li> <li>you access the Lambda function via a Lambda Function URL or Amazon API Gateway</li> </ul>"},{"location":"deploy_aws_lambda_console/#prerequisites","title":"Prerequisites","text":"<p>You must have an AWS account and permission to deploy Lambda functions, create/write to an S3 bucket, and configure API Gateway.</p>"},{"location":"deploy_aws_lambda_console/#upload-configuration-to-s3-bucket","title":"Upload configuration to S3 bucket","text":"<p>We are going to store the Imposter configuration files in an S3 bucket. Upload your configuration files to the S3 bucket, under a path such as <code>config</code>.</p> <p>For the purposes of this guide, we will assume you have uploaded the configuration to a bucket named <code>example-imposter-bucket</code>, so the full path to the configuration file would be:</p> <pre><code>s3://example-imposter-bucket/config/imposter-config.yaml\n</code></pre> <p>You may add related files here, such as response files, specifications etc.</p> <pre><code>s3://example-imposter-bucket/config/openapi-spec.yaml\ns3://example-imposter-bucket/config/response.json\n...\n</code></pre>"},{"location":"deploy_aws_lambda_console/#deployment-steps","title":"Deployment steps","text":"<p>This method uses the AWS Web Console to create a Lambda function, and enables you to call it using the Lambda Function URL.</p>"},{"location":"deploy_aws_lambda_console/#step-1-upload-imposter-to-an-s3-bucket","title":"Step 1: Upload Imposter to an S3 bucket","text":"<p>The Imposter engine for AWS Lambda is packaged as a ZIP file. You should upload this file to an S3 bucket, from where it will be referenced by your Lambda function.</p> <p>Open the AWS S3 Console. Upload the <code>imposter-awslambda.zip</code> file from the Releases page to an S3 bucket.</p> <p>For the purposes of this guide, we will assume you have uploaded the ZIP file to a bucket named <code>example-imposter-bucket</code>, so the full path to the file would be:</p> <pre><code>s3://example-imposter-bucket/imposter-awslambda.zip\n</code></pre>"},{"location":"deploy_aws_lambda_console/#step-2-create-your-lambda-function","title":"Step 2: Create your Lambda function","text":"<p>Open the AWS Lambda Console. Create a new function using the file you uploaded to S3 as the code source.</p> <p>Important: Set the following:</p> <ul> <li>runtime: <code>Java 11</code></li> <li>architecture: <code>x86_64</code> or <code>arm64</code></li> </ul> <p></p>"},{"location":"deploy_aws_lambda_console/#step-3-set-handler","title":"Step 3: Set handler","text":"<p>Under Runtime settings set the handler to: <code>io.gatehill.imposter.awslambda.HandlerV2</code></p> <p></p>"},{"location":"deploy_aws_lambda_console/#step-4-set-environment-variables","title":"Step 4: Set environment variables","text":"<p>Under Configuration, add the following environment variable:</p> <pre><code>IMPOSTER_CONFIG_DIR=\"s3://example-imposter-bucket/config/\"\n</code></pre> <p>Set the environment variable to point to the path holding the configuration files:</p> <p>Note: this is not the path to the YAML file - it is the directory ('prefix') under which the file exists in the bucket.</p> <p>Important: Ensure the Lambda execution role has permission to access the S3 bucket containing your configuration.</p> <p>See deploy/example/bucket-policy.json for an example IAM role.</p> <p></p>"},{"location":"deploy_aws_lambda_console/#step-5-enable-function-url","title":"Step 5: Enable function URL","text":"<p>Under Configuration, enable the 'Function URL' option - this will create an HTTPS endpoint for you to access Imposter.</p> <p></p> <p>Once you have created it, you should see the Function URL:</p> <p></p>"},{"location":"deploy_aws_lambda_console/#step-6-test-the-function","title":"Step 6: Test the function","text":"<p>If all has gone well, you should be able to reach your Lambda function using the Function URL:</p> <pre><code>$ curl https://&lt;Lambda Function URL&gt;/system/status\n\n{ \"status\": \"ok\" }\n</code></pre>"},{"location":"deploy_aws_lambda_console/#whats-next","title":"What's next","text":"<ul> <li>Learn how to use Imposter with the Configuration guide.</li> </ul>"},{"location":"deploy_aws_lambda_serverless_framework/","title":"Deploy Imposter to AWS Lambda using Serverless Framework","text":"<p>This section describes how to deploy Imposter as an AWS Lambda function using Serverless Framework.</p>"},{"location":"deploy_aws_lambda_serverless_framework/#other-ways-to-deploy-to-lambda","title":"Other ways to deploy to Lambda","text":"<p>You can also deploy Imposter as a Lambda function using the Imposter CLI, infrastructure as code tools (e.g. Terraform) or the AWS Console.</p>"},{"location":"deploy_aws_lambda_serverless_framework/#overview","title":"Overview","text":"<p>The key steps are:</p> <ul> <li>you upload the Imposter configuration files to an S3 bucket</li> <li>you create a Serverless Framework configuration file referring to the Imposter Lambda ZIP file and configuration path in S3</li> <li>you deploy the function using the Serverless Framework</li> <li>you access the Lambda function via a Lambda Function URL or Amazon API Gateway</li> </ul>"},{"location":"deploy_aws_lambda_serverless_framework/#prerequisites","title":"Prerequisites","text":"<p>You must have an AWS account and permission to deploy Lambda functions, create/write to an S3 bucket, and configure API Gateway.</p>"},{"location":"deploy_aws_lambda_serverless_framework/#upload-configuration-to-s3-bucket","title":"Upload configuration to S3 bucket","text":"<p>We are going to store the Imposter configuration files in an S3 bucket. Upload your configuration files to the S3 bucket, under a path such as <code>config</code>.</p> <p>For the purposes of this guide, we will assume you have uploaded the configuration to a bucket named <code>example-imposter-bucket</code>, so the full path to the configuration file would be:</p> <pre><code>s3://example-imposter-bucket/config/imposter-config.yaml\n</code></pre> <p>You may add related files here, such as response files, specifications etc.</p> <pre><code>s3://example-imposter-bucket/config/openapi-spec.yaml\ns3://example-imposter-bucket/config/response.json\n...\n</code></pre>"},{"location":"deploy_aws_lambda_serverless_framework/#deployment-steps","title":"Deployment steps","text":"<p>This method uses the Serverless Framework to create a Lambda function, and enables you to call it using the Lambda Function URL.</p>"},{"location":"deploy_aws_lambda_serverless_framework/#step-1-install-serverless-framework","title":"Step 1: Install Serverless Framework","text":"<p>Install the Serverless Framework:</p> <pre><code>npm install -g serverless\n</code></pre> <p>See the Serverless Framework getting started documentation.</p>"},{"location":"deploy_aws_lambda_serverless_framework/#step-2-download-the-zip-file","title":"Step 2: Download the ZIP file","text":"<p>Download the <code>imposter-awslambda.zip</code> file from the Releases page.</p>"},{"location":"deploy_aws_lambda_serverless_framework/#step-3-configure-the-function","title":"Step 3: Configure the function","text":"<p>Create the following configuration file, named <code>serverless.yml</code>:</p> <pre><code>service: aws-imposter-example\nframeworkVersion: '3'\n\nprovider:\n  name: aws\n  runtime: java11\n\n  # permit the function to fetch the config from an S3 bucket named 'imposter-lambda-example'\n  iamRoleStatements:\n    - Effect: \"Allow\"\n      Action: \"s3:GetObject\"\n      Resource: \"arn:aws:s3:::imposter-lambda-example/*\"\n    - Effect: \"Allow\"\n      Action: \"s3:ListBucket\"\n      Resource: \"arn:aws:s3:::imposter-lambda-example\"\n\npackage:\n  individually: true\n\nfunctions:\n  imposter:\n    handler: \"io.gatehill.imposter.awslambda.HandlerV2\"\n    timeout: 30\n    url: true\n    package:\n      artifact: \"./imposter-awslambda.zip\"\n    environment:\n      IMPOSTER_CONFIG_DIR: \"s3://imposter-lambda-example/config/\"\n</code></pre> <p>Note: <code>IMPOSTER_CONFIG_DIR</code> is not the path to the YAML file - it is the directory ('prefix') under which the file exists in the bucket.</p> <p>Important: Ensure the Lambda execution role has permission to access the S3 bucket containing your configuration.</p> <p>See deploy/example/bucket-policy.json for an example IAM role.</p> <p>Deploy your Lambda function with the Serverless CLI:</p> <pre><code>serverless deploy\n</code></pre>"},{"location":"deploy_aws_lambda_serverless_framework/#step-4-test-the-function","title":"Step 4: Test the function","text":"<p>If all has gone well, you should be able to reach your Lambda function using the Function URL:</p> <pre><code>$ curl https://&lt;Lambda Function URL&gt;/system/status\n\n{ \"status\": \"ok\" }\n</code></pre>"},{"location":"deploy_aws_lambda_serverless_framework/#whats-next","title":"What's next","text":"<ul> <li>Learn how to use Imposter with the Configuration guide.</li> </ul>"},{"location":"deployment_patterns/","title":"Deployment patterns","text":"<p>This section describes common deployment patterns for the mock engine and configuration.</p>"},{"location":"deployment_patterns/#external-configuration","title":"External configuration","text":"<p>When deploying Imposter as a container or serverless function, a common pattern is to store configuration in an external store, such as a storage bucket.</p> <p>For example, when deploying Imposter on AWS Lambda, configuration can be held in an S3 bucket.</p> <pre><code>C4Context\n\ntitle External configuration pattern\n\nPerson(client, \"Person\", \"Client accessing the mock\")\nPerson(developer, \"Developer\", \"Develops the mock\")\nSystem(mock, \"Mock\", \"Imposter mock engine\")\nSystemDb(config_store, \"S3\", \"Configuration store\")\n\nRel(developer, mock, \"Deploys the mock engine\")\nRel(developer, config_store, \"Deploys the mock configuration\")\nRel(client, mock, \"Calls the mock\")\nRel(mock, config_store, \"Fetches mock configuration\")\n\nUpdateLayoutConfig($c4ShapeInRow=\"2\", $c4BoundaryInRow=\"1\")\n</code></pre>"},{"location":"deployment_patterns/#advantages","title":"Advantages","text":"<ul> <li>Engine and configuration can be deployed independently</li> <li>Size of configuration deployment package is small as it does not include the mock engine as well</li> </ul>"},{"location":"deployment_patterns/#disadvantages","title":"Disadvantages","text":"<ul> <li>Separate deployment steps required when updating mock engine and configuration</li> <li>Engine and configuration must be kept in sync by an external mechanism</li> <li>Engine must be restarted by an external mechanism to pick up new configuration</li> </ul>"},{"location":"deployment_patterns/#bundled-configuration","title":"Bundled configuration","text":"<p>When deploying Imposter as a container or serverless function, it is possible to bundle the configuration and engine in the same deployment unit (e.g. container image or Lambda ZIP file). This avoids the need for an external configuration store.</p> <pre><code>C4Context\n\ntitle Bundled configuration pattern\n\nPerson(client, \"Person\", \"Client accessing the mock\")\nPerson(developer, \"Developer\", \"Develops the mock\")\nSystem(mock, \"Mock\", \"Imposter mock engine and configuration\")\n\nRel(developer, mock, \"Deploys the mock engine and config\")\nRel(client, mock, \"Calls the mock\")\n\nUpdateLayoutConfig($c4ShapeInRow=\"2\", $c4BoundaryInRow=\"1\")\n</code></pre>"},{"location":"deployment_patterns/#advantages_1","title":"Advantages","text":"<ul> <li>Engine and configuration can be deployed in a single step</li> <li>Engine and configuration don't require an external mechanism to keep them in sync</li> <li>Engine does not have to be restarted by an external mechanism to pick up new configuration</li> </ul>"},{"location":"deployment_patterns/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>Engine is also deployed when updating configuration</li> <li>Combined deployment package is larger than deploying configuration alone</li> </ul>"},{"location":"deployment_patterns/#how-to-bundle-configuration","title":"How to bundle configuration","text":"<p>Bundling keeps all elements of the mock in a single package, simplifying deployment and distribution of your mocks.</p> <p>See the Bundle configuration section for instructions on how to bundle configuration for different deployment targets.</p>"},{"location":"directory_responses/","title":"Directory-based responses","text":""},{"location":"directory_responses/#overview","title":"Overview","text":"<p>The directory-based response feature allows you to serve files from a directory based on the incoming request path. This is useful when you want to serve multiple files without having to configure each response individually.</p>"},{"location":"directory_responses/#configuration","title":"Configuration","text":"<p>The feature is configured using two key elements: 1. A trailing wildcard (<code>*</code>) in the request path matcher 2. A <code>dir</code> property in the response configuration that points to the directory containing response files</p>"},{"location":"directory_responses/#behavior","title":"Behavior","text":"<ul> <li>When a request matches a path pattern with a wildcard, the system:<ol> <li>Takes the part of the actual request path that matches after the non-wildcard portion</li> <li>Looks for a file with that name in the specified directory</li> <li>Serves that file as the response</li> </ol> </li> <li>Content-Type is automatically inferred from the file extension</li> <li>If no matching file is found, returns a 500 error</li> <li>If the path pattern doesn't contain a wildcard but <code>dir</code> is specified, Imposter returns an HTTP 500 error</li> <li>If the request path ends with a <code>/</code>, Imposter looks for a file named <code>index.html</code> in the directory</li> </ul>"},{"location":"directory_responses/#requirements","title":"Requirements","text":"<ul> <li>The request matcher path MUST end with a wildcard (<code>*</code>)</li> <li>The <code>dir</code> property MUST be specified in the response configuration</li> <li>The directory path is relative to the config file location</li> </ul>"},{"location":"directory_responses/#example-configuration","title":"Example Configuration","text":"<p>Assuming the following directory structure:</p> <pre><code>imposter-config.yaml\nresponses/\n  example1.json\n  data/\n    example3.json\n</code></pre> <p>Here's an example configuration:</p> <pre><code># imposter-config.yaml\n---\nresources:\n- request:\n  method: GET\n  # Wildcard path pattern\n  path: /api/responses/*\n  response:\n    # Directory containing response files\n    dir: responses # Directory containing response files\n</code></pre> <p>This would match: <pre><code>GET /api/responses/example1.json -&gt; serves responses/example1.json\nGET /api/responses/data/example3.json -&gt; serves responses/data/example3.json\n</code></pre></p>"},{"location":"embed_jvm/","title":"Embedding Imposter in your JVM tests","text":"<p>You can embed the Imposter in your JVM tests, such as JUnit or TestNG.</p> <p>Typically, Imposter starts before your tests, providing synthetic responses to your unit under test. You connect your component under test to the mock HTTP endpoint provided by Imposter.</p> <p>Imposter starts before your test runs, such as in your test set-up method (e.g. <code>@BeforeEach</code> in JUnit), providing your application with simulated HTTP responses, in place of a real endpoint.</p>"},{"location":"embed_jvm/#getting-started","title":"Getting started","text":"<p>For a full working example project, see examples/junit-sample</p> <p>First, note the latest release version.</p> <p>Add the following Maven repository to your build tool:</p> <pre><code>https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases\n</code></pre> <p>Add the following Maven dependencies in your build tool:</p> Component Group ID Artifact ID Version Main library <code>io.gatehill.imposter</code> <code>distro-embedded</code> As per Releases, e.g. <code>4.2.2</code> HTTP server <code>io.gatehill.imposter</code> <code>imposter-server</code> As per Releases, e.g. <code>4.2.2</code> Config parser <code>io.gatehill.imposter</code> <code>config-dynamic</code> As per Releases, e.g. <code>4.2.2</code> OpenAPI plugin <code>io.gatehill.imposter</code> <code>mock-openapi</code> As per Releases, e.g. <code>4.2.2</code> <p>See the Dependencies section for full Maven and Gradle examples.</p>"},{"location":"embed_jvm/#openapi-example","title":"OpenAPI example","text":"<p>It is best to use a plugin-specific builder if it exists, such as <code>io.gatehill.imposter.openapi.embedded.OpenApiImposterBuilder</code> for the OpenAPI plugin.</p> <p>Let's assume you have an OpenAPI specification file:</p> <pre><code>Path specFile = Paths.get(\"/path/to/openapi_file.yaml\");\n</code></pre> <p>Example using an OpenAPI spec as the source:</p> <pre><code>MockEngine imposter = new OpenApiImposterBuilder&lt;&gt;()\n        .withSpecificationFile(specFile)\n        .startBlocking();\n\n// mockEndpoint will look like http://localhost:5234/v1/pets\nString mockEndpoint = imposter.getBaseUrl() + \"/v1/pets\";\n\n// Your component under test can interact with this endpoint to get\n// simulated HTTP responses, in place of a real endpoint.\n</code></pre> <p>For a full working example project, see examples/junit-sample</p>"},{"location":"embed_jvm/#using-a-full-configuration-file","title":"Using a full configuration file","text":"<p>You can also get access to advanced Imposter features by using a standard configuration file. Pass the path to the directory containing the configuration file:</p> <pre><code>String configDir = Paths.get(\"/path/to/config_dir\");\n</code></pre> <p>Example using a directory containing an Imposter configuration file:</p> <pre><code>MockEngine imposter = new ImposterBuilder&lt;&gt;()\n        .withPluginClass(OpenApiPluginImpl.class)\n        .withConfigurationDir(configDir)\n        .startBlocking();\n\n// mockEndpoint will look like http://localhost:5234/v1/pets\nString mockEndpoint = imposter.getBaseUrl() + \"/v1/pets\";\n\n// Your component under test can interact with this endpoint to get\n// simulated HTTP responses, in place of a real endpoint.\n</code></pre> <p>Note the need to specify the plugin, which was implicit in the example above.</p>"},{"location":"embed_jvm/#dependencies","title":"Dependencies","text":"<p>Build tool configuration for Gradle and Maven.</p>"},{"location":"embed_jvm/#gradle","title":"Gradle","text":"<p>Using Gradle, add the following to your build configuration:</p> <pre><code>ext {\n    // choose latest release from: https://github.com/imposter-project/imposter-jvm-engine/releases\n    imposter_version = '4.2.2'\n}\n\nrepositories {\n    maven {\n        // imposter maven repository\n        url 'https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases/'\n    }\n}\n\ndependencies {\n    testImplementation \"io.gatehill.imposter:distro-embedded:$imposter_version\"\n    testImplementation \"io.gatehill.imposter:imposter-server:$imposter_version\"\n    testImplementation \"io.gatehill.imposter:config-dynamic:$imposter_version\"\n    testImplementation \"io.gatehill.imposter:mock-openapi:$imposter_version\"\n\n    // ...\n}\n</code></pre>"},{"location":"embed_jvm/#maven","title":"Maven","text":"<p>Using Maven, add the following to your POM:</p> <pre><code>&lt;project&gt;\n    ...\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;imposter&lt;/id&gt;\n            &lt;url&gt;https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n    ...\n    &lt;properties&gt;\n        &lt;!-- choose latest release from https://github.com/imposter-project/imposter-jvm-engine/releases --&gt;\n        &lt;imposter.version&gt;4.2.2&lt;/imposter.version&gt;\n    &lt;/properties&gt;\n    ...\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.gatehill.imposter&lt;/groupId&gt;\n            &lt;artifactId&gt;distro-embedded&lt;/artifactId&gt;\n            &lt;version&gt;${imposter.version}&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.gatehill.imposter&lt;/groupId&gt;\n            &lt;artifactId&gt;imposter-server&lt;/artifactId&gt;\n            &lt;version&gt;${imposter.version}&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.gatehill.imposter&lt;/groupId&gt;\n            &lt;artifactId&gt;config-dynamic&lt;/artifactId&gt;\n            &lt;version&gt;${imposter.version}&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.gatehill.imposter&lt;/groupId&gt;\n            &lt;artifactId&gt;mock-openapi&lt;/artifactId&gt;\n            &lt;version&gt;${imposter.version}&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        ...\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"embed_jvm/#other-plugins","title":"Other plugins","text":"<p>Imposter supports a range of plugins, such as SOAP/WSDL and RESTful services. Here are some examples:</p> Component Group ID Artifact ID More information SOAP/WSDL mocks <code>io.gatehill.imposter</code> <code>mock-soap</code> See SOAP plugin RESTful mocks <code>io.gatehill.imposter</code> <code>mock-rest</code> See REST plugin <p>See the Plugins section for more.</p>"},{"location":"environment_variables/","title":"Environment variables","text":"<p>The following environment variables are supported:</p> Variable name Purpose Default Description/example(s) IMPOSTER_ADD_ENGINE_RESPONSE_HEADERS Add response headers for <code>server</code> and unique request ID. <code>true</code> <code>false</code> IMPOSTER_AUTO_BASE_PATH Automatically set the base path for each configuration file, based on its relative path from the configuration root directory. <code>false</code> <code>true</code> IMPOSTER_CACHE_DIR Path to a directory in which to store cached data, such as remote specifications. <code>&lt;Java temporary directory&gt;/imposter-cache</code> <code>/path/to/dir</code> IMPOSTER_CONFIG_DIR The path to the configuration directory. Can be specified as a comma-separated list. See configuration location. Empty <code>/path/to/config/dir</code> - See Configuration Location. IMPOSTER_CONFIG_SCAN_RECURSIVE Scan for configuration files recursively within the configuration directories. See recursive configuration discovery. <code>false</code> <code>true</code> IMPOSTER_CONFIG_DISCOVER_ENVFILES Discover envfiles. See below. <code>true</code> <code>false</code> IMPOSTER_ESCAPE_COLONS_IN_PATH Escape colons in paths. <code>false</code> <code>true</code> IMPOSTER_FEATURES Enables or disables features. See Features documentation. Per default features. <code>metrics=false,stores=true</code> IMPOSTER_IGNORE_CONFIG_ERRORS Log errors encountered during configuration parsing or plugin configuration instead of throwing an exception. Defaults to <code>false</code>, as skipping a configuration might also skip the security conditions it contains. <code>false</code> boolean IMPOSTER_JS_PLUGIN Sets the JavaScript implementation. <code>js-graal</code> Can be changed to <code>js-nashorn</code> plugin, if installed. IMPOSTER_LOG_LEVEL Sets logging level. <code>DEBUG</code> <code>INFO</code>, <code>DEBUG</code>, <code>TRACE</code> IMPOSTER_LOG_REQUEST_BODY Include request in structured log entries. <code>false</code> <code>true</code> - See Metrics, logs and telemetry. IMPOSTER_LOG_REQUEST_HEADERS Comma separated list of request headers to add to structured log entries. Empty <code>X-Correlation-ID,User-Agent</code> - See Metrics, logs and telemetry. IMPOSTER_LOG_RESPONSE_BODY Include response in structured log entries. <code>false</code> <code>true</code> - See Metrics, logs and telemetry. IMPOSTER_LOG_RESPONSE_HEADERS Comma separated list of response headers to add to structured log entries. Empty <code>Server,Content-Type</code> - See Metrics, logs and telemetry. IMPOSTER_LOG_SUMMARY Log a JSON formatted summary message on each request. <code>false</code> <code>true</code> IMPOSTER_LOG_SUMMARY_PRETTY Pretty print the summary log JSON. <code>false</code> <code>true</code> IMPOSTER_NORMALISE_HEADER_KEYS Forces header keys to be lowercased. <code>true</code> boolean IMPOSTER_OPENAPI_EXPOSE_SPEC Expose the OpenAPI specification and UI. See OpenAPI plugin. <code>true</code> <code>false</code> IMPOSTER_OPENAPI_REMOTE_FILE_CACHE Locally cache remote OpenAPI specifications. See OpenAPI plugin. <code>false</code> <code>true</code> IMPOSTER_OPENAPI_SPEC_PATH_PREFIX Overrides the default specification path prefix. See OpenAPI plugin. <code>/_spec</code> <code>/openapi-spec</code> IMPOSTER_OPENAPI_VALIDATION_DEFAULT_BEHAVIOUR The default behaviour for OpenAPI validation issues. See OpenAPI validation. <code>IGNORE</code> See OpenAPI validation. IMPOSTER_PLUGIN_ARGS Comma separated map of plugin arguments. Analogous to <code>--pluginArg</code> command line argument. Empty <code>openapi.scheme=https,openapi.title=Mocks</code> IMPOSTER_PLUGIN_CLASSLOADER_STRATEGY Sets the classloader strategy for plugins. Parent-first <code>child</code> IMPOSTER_PLUGIN_DIR Path to a directory containing additional plugin JAR files. Empty Used by Stores and Plugins. IMPOSTER_PREFER_EXACT_MATCH_ROUTES Prefer routes with exact matches over those with path placeholders when matching requests. <code>true</code> boolean IMPOSTER_STORE_DRIVER Sets the store driver plugin. <code>store-inmem</code> See Stores. IMPOSTER_STORE_KEY_PREFIX Sets a prefix for store keys. Empty See Stores. IMPOSTER_SCRIPT_CACHE_ENTRIES The number of precompiled scripts to cache. Precompiled scripts execute faster, but the cache uses memory. <code>20</code> <code>30</code> IMPOSTER_SCRIPT_PRECOMPILE Precompile scripts at startup. <code>true</code> boolean IMPOSTER_RESPONSE_FILE_CACHE_ENTRIES The number of response files to cache in memory. Cached response files don't require disk I/O, but the cache uses memory. <code>20</code> <code>30</code> IMPOSTER_YAML_CODE_POINT_LIMIT The maximum number of characters to parse in a YAML file. The default is 3MB. Note that the size depends on the file encoding. <code>3145728</code> (3MB) <code>10485760</code> (10MB) <p>Note: other features may include their own environment variables. See the feature specific documentation for more details.</p>"},{"location":"environment_variables/#setting-environment-variables-using-a-file","title":"Setting environment variables using a file","text":"<p>You can use an environment file ('envfile') to pass environment variables to Imposter. To do this, add a file named <code>.env</code> adjacent to your configuration files, for example:</p> <pre><code>$ ls\n.env\nimposter-config.yaml\n\n$ cat .env\nIMPOSTER_LOG_LEVEL=info\nOTHER_ENV_VAR=example\n</code></pre>"},{"location":"extend/","title":"Extending Imposter in a custom application","text":"<p>You can extend Imposter to build a custom JVM application.</p> <p>See <code>io.gatehill.imposter.server.ImposterVerticle</code> for an example of how to bootstrap the mock server.</p>"},{"location":"extend/#dependencies","title":"Dependencies","text":"<p>Add the Imposter dependencies to your build tool.</p>"},{"location":"extend/#gradle","title":"Gradle","text":"<p>To add dependencies on Imposter, using Gradle, add the following to your build configuration:</p> <pre><code>ext {\n    // choose latest release from: https://github.com/imposter-project/imposter-jvm-engine/releases\n    imposter_version = '1.0.0'\n}\n\nrepositories {\n    maven {\n        // imposter maven repository\n        url 'https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases/'\n    }\n}\n\n\ndependencies {\n    // core imposter dependencies\n    implementation \"io.gatehill.imposter:core:imposter-engine:$imposter_version\"\n    implementation \"io.gatehill.imposter:imposter-server:$imposter_version\"\n\n    // specific plugins\n    implementation \"io.gatehill.imposter:mock-openapi:$imposter_version\"\n\n    // ...\n}\n</code></pre>"},{"location":"extend/#maven","title":"Maven","text":"<p>Using Maven, add the following to your POM:</p> <pre><code>&lt;project&gt;\n    ...\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;imposter&lt;/id&gt;\n            &lt;url&gt;https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n    ...\n    &lt;properties&gt;\n        &lt;!-- choose latest release from https://github.com/imposter-project/imposter-jvm-engine/releases --&gt;\n        &lt;imposter.version&gt;1.0.0&lt;/imposter.version&gt;\n    &lt;/properties&gt;\n    ...\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.gatehill.imposter&lt;/groupId&gt;\n            &lt;artifactId&gt;imposter-core&lt;/artifactId&gt;\n            &lt;version&gt;${imposter.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.gatehill.imposter&lt;/groupId&gt;\n            &lt;artifactId&gt;imposter-server&lt;/artifactId&gt;\n            &lt;version&gt;${imposter.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.gatehill.imposter&lt;/groupId&gt;\n            &lt;artifactId&gt;mock-openapi&lt;/artifactId&gt;\n            &lt;version&gt;${imposter.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        ...\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"failure_simulation/","title":"Failure simulation","text":"<p>Imposter can simulate failure types to enable you to test adverse scenarios, such as the connection being closed without receiving a response.</p>"},{"location":"failure_simulation/#injecting-failures","title":"Injecting failures","text":"<p>Failures can be injected via configuration or using a script driven approach.</p> <p>The failure takes effect after any request processing has completed (scripts, plugins etc.) but before the response is sent.</p> <p>Note Failures can also be combined with performance simulation effects. For example to simulate a delay followed by a closed connection.</p> <p>The supported failure types are:</p> Failure type Effect Configuration value Empty response Send an empty HTTP response <code>EmptyResponse</code> Close connection Close the connection before sending a response <code>CloseConnection</code>"},{"location":"failure_simulation/#configuration-driven","title":"Configuration driven","text":"<p>Specify the <code>fail</code> option in configuration:</p> <pre><code># ...\n\nresources:\n  - method: GET\n    path: /example1\n    response:\n      # send an empty HTTP response\n      fail: EmptyResponse\n\n  - method: GET\n    path: /example2\n    response:\n      # close the connection before sending a response\n      fail: CloseConnection\n</code></pre>"},{"location":"failure_simulation/#script-driven","title":"Script driven","text":"<p>If using Scripting, use the <code>withFailure(...)</code> method.</p> <p>To send an empty response:</p> <pre><code>respond().withFailure('EmptyResponse')\n</code></pre> <p>To close the connection:</p> <pre><code>respond().withFailure('CloseConnection')\n</code></pre>"},{"location":"failure_simulation/#logs","title":"Logs","text":"<p>You will see log entries similar to the following:</p> <pre><code>15:39:09 INFO  i.g.i.s.CharacteristicsService - \n  Simulating EmptyResponse failure for GET http://localhost:50204/example1\n</code></pre>"},{"location":"fake_data/","title":"Generating fake data","text":"<p>You can generate fake data for fields in your mock.</p> <p>Examples include, but are not limited to:</p> <ul> <li>Names</li> <li>Email addresses</li> <li>Addresses</li> </ul>"},{"location":"fake_data/#setup","title":"Setup","text":""},{"location":"fake_data/#option-1-using-the-fake-data-plugin","title":"Option 1: Using the <code>fake-data</code> plugin","text":"<p>To use it, install the <code>fake-data</code> plugin:</p> <pre><code>imposter plugin install -d fake-data\n</code></pre>"},{"location":"fake_data/#option-2-using-the-all-distribution","title":"Option 2: Using the 'all' distribution","text":"<p>Alternatively, you can use the <code>all</code> distribution, which includes the <code>fake-data</code> plugin.</p> <p>This is the <code>docker-all</code> engine type if you're using the CLI or the <code>imposter-all.jar</code> file if you're using the JAR file approach.</p>"},{"location":"fake_data/#generating-fake-data_1","title":"Generating fake data","text":""},{"location":"fake_data/#fake-data-expressions","title":"Fake data expressions","text":"<p>You can use template expressions in responses to insert fake data. The expressions start with <code>fake.</code> followed by a type of fake data to generate.</p> <p>For example, to return a random first name, use the following expression:</p> <pre><code>${fake.Name.firstName}\n</code></pre> <p>For an email address:</p> <pre><code>${fake.Internet.emailAddress}\n</code></pre> <p>Some common examples:</p> Fake data Expression First name <code>fake.Name.firstName</code> Last name <code>fake.Name.lastName</code> Email address <code>fake.Internet.emailAddress</code> Username <code>fake.Name.username</code> Street address <code>fake.Address.streetAddress</code> City <code>fake.Address.city</code> Country <code>fake.Address.country</code> Phone number <code>fake.PhoneNumber.phoneNumber</code> <p>Note Valid values are those supported by the Datafaker library.</p>"},{"location":"fake_data/#try-it-out","title":"Try it out","text":"<p>See the example directory for a working example.</p> <pre><code>curl http://localhost:8080/users/1\n</code></pre> <pre><code>{\n  \"id\": 1,\n  \"firstName\": \"Linda\",\n  \"lastName\": \"Smith\",\n  \"email\": \"linda@example.com\"\n}\n</code></pre>"},{"location":"fake_data/#fake-data-in-openapi-specs","title":"Fake data in OpenAPI specs","text":"<p>Note This section applies to the OpenAPI plugin.</p> <p>When using the <code>fake-data</code> plugin with the OpenAPI plugin, common property names in the OpenAPI specification, such as <code>firstName</code>, <code>email</code> etc., are replaced with fake data. This happens when no matching example is found in the specification.</p>"},{"location":"fake_data/#try-it-out_1","title":"Try it out","text":"<p>See the example directory for a working example.</p> <p>For example:</p> <pre><code>curl http://localhost:8080/users/1\n</code></pre> <pre><code>{\n  \"id\": 1,\n  \"firstName\": \"Linda\",\n  \"lastName\": \"Smith\",\n  \"email\": \"linda@example.com\",\n  \"address\": {\n    \"street\": \"123 Main St\",\n    \"city\": \"New York\",\n    \"postcode\": \"10001\"\n  },\n  \"favouriteColour\": \"red\"\n}\n</code></pre>"},{"location":"fake_data/#customizing-the-fake-data","title":"Customizing the fake data","text":"<p>You can customize the fake data by adding a <code>x-fake-data</code> property to the field in the OpenAPI file.</p> <p>This is done for the <code>favouriteColour</code> field in the example:</p> <pre><code>favouriteColour:\n  type: string\n  x-fake-data: Color.name\n</code></pre> <p>Note Valid values are those supported by the Datafaker library.</p>"},{"location":"features/","title":"Features","text":"<p>Imposter allows certain features to be enabled or disabled. Fewer features generally lowers resource requirements.</p> <p>Also see the Plugins documentation for a list of available and built-in plugins.</p>"},{"location":"features/#list-of-features","title":"List of features","text":"Feature name Purpose Details Enabled by default <code>metrics</code> Collects and exposes telemetry. Metrics <code>true</code> <code>stores</code> Persistent or semi-persistent state. Stores <code>true</code> <p>These can be controlled by setting the environment variable <code>IMPOSTER_FEATURES</code>:</p> <pre><code>IMPOSTER_FEATURES=\"stores=false,metrics=true\"\n</code></pre> <p>...or Java system property <code>imposter.features</code>:</p> <pre><code>-Dimposter.features=\"stores=false,metrics=true\"\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>There are many ways to run Imposter. There are two categories: run a standalone server, or embed it within unit/integration tests.</p>"},{"location":"getting_started/#standalone-mock-server","title":"Standalone mock server","text":"<ul> <li>Using the command line client - see Imposter CLI</li> <li>As a Docker container - see Imposter Docker container</li> <li>As a Lambda function in AWS - see Imposter AWS Lambda</li> <li>As a JAR file on the JVM - see Imposter JAR file</li> </ul>"},{"location":"getting_started/#embed-in-unitintegration-tests","title":"Embed in unit/integration tests","text":"<ul> <li>Embed within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings</li> <li>Embed within your JavaScript/Node.js unit tests - see JavaScript bindings</li> </ul>"},{"location":"getting_started/#within-your-cicd-pipeline","title":"Within your CI/CD pipeline","text":"<ul> <li>Use the Imposter GitHub Actions to start and stop Imposter during your CI/CD pipeline.</li> </ul>"},{"location":"getting_started/#choosing-an-approach","title":"Choosing an approach","text":"<p>If you are looking for a quick local development solution, use the CLI.</p> <p>If you want to run Imposter as a standalone mock server, you can run it as a Docker container. If Docker isn't your thing, or you want to build Imposter yourself, you can use it as a standalone JAR file. Standalone servers are often useful when you require long-lived mock instances.</p> <p>You can also use it as a mock server for your unit tests on the JVM or Node.js, starting it before your tests, providing synthetic responses to your unit under test. Embedded instances tend to be short-lived and exist only for the duration of your test execution.</p>"},{"location":"getting_started/#examples","title":"Examples","text":"<p>Let's assume your configuration is in a folder named <code>config</code>.</p> <p>CLI example:</p> <pre><code>imposter up ./config -p 8080\n</code></pre> <p>Docker example:</p> <pre><code>docker run -ti -p 8080:8080 -v $PWD/config:/opt/imposter/config outofcoffee/imposter\n</code></pre> <p>Standalone Java example:</p> <pre><code>java -jar ./imposter.jar --configDir ./config\n</code></pre> <p>Your mock server is now running!</p> <p>These examples start a mock server using the simple REST plugin, serving responses based on the configuration files inside the <code>config</code> folder. You can hit the URL http://localhost:8080/example to see the mock response.</p>"},{"location":"getting_started/#whats-next","title":"What's next","text":"<p>Learn how to use Imposter with the Configuration guide.</p>"},{"location":"github_actions/","title":"Run Imposter with GitHub Actions","text":"<p>If you're using GitHub Actions for your CI/CD pipeline, you can run Imposter to mock your dependencies during testing.</p> Other ways to run Imposter <p>Standalone mock server</p> <ul> <li>Using the command line client - see Imposter CLI</li> <li>As a Docker container - see Imposter Docker container</li> <li>As a Lambda function in AWS - see Imposter AWS Lambda</li> <li>As a JAR file on the JVM - see Imposter JAR file</li> </ul> <p>Embed in unit/integration tests</p> <ul> <li>Embed within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings</li> <li>Embed within your JavaScript/Node.js unit tests - see JavaScript bindings</li> </ul> <p>This guide will show you how to start and stop mocks with GitHub Actions.</p>"},{"location":"github_actions/#available-actions","title":"Available Actions","text":"<p>Note Replace <code>v1</code> in the examples below with the latest release of the GitHub Actions.</p>"},{"location":"github_actions/#1-setup-imposter-setup","title":"1. Setup Imposter (<code>setup</code>)","text":"<p>Downloads and installs the Imposter mock server.</p> <pre><code>- uses: imposter-project/imposter-github-action/setup@v1\n</code></pre>"},{"location":"github_actions/#2-start-mocks-start-mocks","title":"2. Start Mocks (<code>start-mocks</code>)","text":"<p>Starts the Imposter mock server in the background, and waits for it to be ready.</p> <pre><code>- uses: imposter-project/imposter-github-action/start-mocks@v1\n  with:\n    # Optional: Path to the directory containing the Imposter configuration files\n    config-dir: './mocks'      # default: './mocks'\n    # Optional: Port number for the Imposter server\n    port: '8080'               # default: '8080'\n    # Optional: Version of the Imposter mock engine to use\n    version: '1.2.3'           # default: '' (latest)\n    # Optional: Type of mock engine to use (jvm or docker)\n    engine-type: 'docker'      # default: 'docker'\n    # Optional: Whether to recursively scan the config directory\n    recursive-config-scan: 'false'  # default: 'false'\n</code></pre> Advanced configuration options <ul> <li><code>auto-restart</code>: Whether to automatically restart when configuration changes (default: false)</li> <li><code>max-attempts</code>: Maximum number of attempts to check if the server is ready (default: 30)</li> <li><code>retry-interval</code>: Interval in seconds between retry attempts (default: 1)</li> </ul>"},{"location":"github_actions/#outputs","title":"Outputs","text":"<ul> <li><code>base-url</code>: Base URL of the mock server (e.g. <code>http://localhost:8080</code>)</li> </ul>"},{"location":"github_actions/#3-stop-mocks-stop-mocks","title":"3. Stop Mocks (<code>stop-mocks</code>)","text":"<p>Stops the running Imposter mock server.</p> <pre><code>- uses: imposter-project/imposter-github-action/stop-mocks@v1\n  with:\n    # Optional: Type of mock engine to use (jvm or docker)\n    engine-type: 'docker'      # default: 'docker'\n</code></pre>"},{"location":"github_actions/#sample-workflow","title":"Sample Workflow","text":"<p>Here's a complete example showing how to use all three actions in a workflow:</p> <pre><code>name: Integration Tests with Mocks\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    # Install Imposter CLI\n    - name: Setup Imposter\n      uses: imposter-project/imposter-github-action/setup@v1\n\n    # Start mock server\n    - name: Start Mocks\n      id: start-mocks\n      uses: imposter-project/imposter-github-action/start-mocks@v1\n      with:\n        config-dir: './mocks'\n        port: '8080'            # Optional: specify port number\n        engine-type: 'docker'   # Optional: specify engine type\n        version: '1.2.3'        # Optional: specify engine version\n        recursive-config-scan: 'true'  # Optional: scan config directory recursively\n\n    # Your test steps here\n    - name: Run Tests\n      run: |\n        # The mock server is available at ${{ steps.start-mocks.outputs.base-url }}\n        echo \"Running tests against mock server at ${{ steps.start-mocks.outputs.base-url }}\"\n\n    # Stop mock server\n    - name: Stop Mocks\n      uses: imposter-project/imposter-github-action/stop-mocks@v1\n      with:\n        engine-type: 'docker'   # Should match the engine-type used in start-mocks\n</code></pre>"},{"location":"github_actions/#configuration","title":"Configuration","text":"<p>The mock server configuration should be placed in your repository according to the <code>config-dir</code> parameter (defaults to <code>./mocks</code>). For detailed information about configuring mocks, see the configuration guide.</p>"},{"location":"github_actions/#further-information","title":"Further information","text":"<p>See the imposter-github-action project for further details.</p>"},{"location":"groovy_debugging/","title":"Debugging Groovy scripts","text":"<p>You can attach a debugger to the JVM to step through your Groovy scripts, inspect variables etc.</p> <p>The key steps involved are:</p> <ol> <li>Enable the JVM debugger, listening on a local port</li> <li>Start Imposter</li> <li>Connect to the debug port</li> </ol>"},{"location":"groovy_debugging/#enable-the-jvm-debugger","title":"Enable the JVM debugger","text":"<p>Enable the JVM debugger with the following environment variable:</p> <pre><code>JAVA_TOOL_OPTIONS=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000\"\n</code></pre> <p>Note Here we have set the debug port to 8000.</p>"},{"location":"groovy_debugging/#docker-users","title":"Docker users","text":"<p>When running in Docker, make sure to expose the debug port.</p> <p>For example:</p> <pre><code>docker run --rm -it -p8080:8080 -p8000:8000 -v $PWD:/opt/imposter/config outofcoffee/imposter\n</code></pre> <p>In this example, port 8000 is exposed along with the regular port, 8080.</p>"},{"location":"groovy_debugging/#cli-users","title":"CLI users","text":"<p>When using the CLI, pass the <code>--debug-mode</code> flag.</p> <p>For example:</p> <pre><code>imposter up --debug-mode\n</code></pre> <p>In this example, port 8000 is exposed along with the regular port, 8080.</p>"},{"location":"groovy_debugging/#steps-for-intellij-idea","title":"Steps for IntelliJ IDEA","text":"<p>This section explains how to connect your IDE's debugger to the debug port.</p> <p>In IntelliJ, create a simple project pointing to the directory containing your script file.</p>"},{"location":"groovy_debugging/#step-by-step","title":"Step-by-step","text":"<p>In the following steps, we will add a new run configuration, start the mock and attach the debugger.</p> <ol> <li>Add a 'Remote JVM Debug' run configuration:    </li> <li>Set the <code>Port</code> to the same value as the debug configuration.</li> <li>Start Imposter and wait for the server to be ready.</li> <li>In IntelliJ start the run configuration in Debug mode, which will connect the debugger to the Imposter JVM.</li> </ol> <p>Set breakpoints in the script file as normal. When your script is invoked in Imposter, the debugger will pause on breakpoints and you can evaluate variables in scope.</p> <p></p>"},{"location":"groovy_tips/","title":"Groovy tips and tricks","text":""},{"location":"groovy_tips/#background","title":"Background","text":"<p>This section provides additional tips and tricks when using Groovy as the scripting language for your mocks. It builds on the Scripting documentation. If you are new to Imposter scripting, it's best to start there.</p>"},{"location":"groovy_tips/#debugging-groovy-scripts","title":"Debugging Groovy scripts","text":"<p>See the debugging Groovy scripts documentation.</p>"},{"location":"groovy_tips/#block-syntax-for-respond","title":"Block syntax for <code>respond</code>","text":"<p>Groovy users can use this special block syntax, for improved readability:</p> <pre><code>respond {\n    // behaviours go here\n}\n</code></pre> <p>For example:</p> <pre><code>respond {\n    withStatusCode 201\n    and()\n    usingDefaultBehaviour()\n}\n</code></pre>"},{"location":"groovy_tips/#parsing-json","title":"Parsing JSON","text":"<p>To parse JSON in the request, you can use the Groovy <code>JsonSlurper</code> class in your scripts.</p> <p>Here's a working example:</p> <pre><code># imposter-config.yaml\nplugin: rest\n\nresources:\n- path: /\n  method: POST\n  response:\n  scriptFile: json-parse.groovy\n</code></pre> <pre><code>// json-parse.groovy\n\ndef parser = new groovy.json.JsonSlurper()\ndef json = parser.parseText(context.request.body)\n\nrespond().withContent(json.hello)\n</code></pre> <p>Example:</p> <pre><code>$ curl -X POST  http://localhost:8080 -d '{ \"hello\": \"world\" }'\n...\nworld\n</code></pre>"},{"location":"groovy_tips/#producing-json-strings","title":"Producing JSON strings","text":"<p>To produce JSON from an object, use the <code>JsonOutput.toJson</code> method.</p> <p>Here's an example:</p> <pre><code>def obj = [ hello: 'world' ]\ndef json = groovy.json.JsonOutput.toJson(obj)\n\nrespond().withContent(json)\n</code></pre>"},{"location":"groovy_tips/#dynamically-loading-other-groovy-scripts","title":"Dynamically loading other Groovy scripts","text":"<p>You can dynamically include another Groovy script file in your script code.</p> <p>Warning: An important consideration with dynamic script inclusion is performance. Normally, when Imposter sees a script file referenced from config, it precompiles it on startup, so that executions of the script are faster. Depending on machine resources, script size, and other factors script execution can be 10x-100x slower without precompilation.</p> <p>If you want to include Groovy scripts dynamically, then you can do something like this:</p> <pre><code>// entrypoint.groovy\n\ndef other = loadDynamic('/path/to/other-script.groovy')\n\nrespond().withStatusCode(other.getStatusCode())\n</code></pre> <p>then in the referenced file you'd have something like:</p> <pre><code>// other-script.groovy\n// this file is included from 'entrypoint.groovy'\n\nint getStatusCode() {\n    return 201\n}\n</code></pre> <p>Note that the result of calling the <code>loadDynamic(..)</code> method is a new Groovy script object. Specifically, the <code>GroovyClassLoader</code> returns a subclass of <code>groovy.lang.Script</code>.</p> <p>This object does not share global state ('bindings') with the calling script, so it doesn't have access to DSL functions like <code>respond()</code> etc.</p> <p>A work-around is use the dynamically-loaded scripts to do computation/logic and return an object for your dispatcher to then use when it calls <code>respond()</code>.</p>"},{"location":"groovy_tips/#adding-a-jar-file-to-the-classpath-for-groovy-scripts","title":"Adding a JAR file to the classpath for Groovy scripts","text":"<p>You can add a JAR file to the classpath for Groovy scripts by adding it to the plugins directory. This will be added to the classpath when the Groovy script is executed.</p> <p>To do this:</p> <ol> <li>create a directory containing the JAR file</li> <li>set the <code>IMPOSTER_PLUGIN_DIR</code> environment variable (or set <code>plugin.dir</code> in your <code>.imposter.yaml</code> file in the config directory) to the path above</li> </ol>"},{"location":"groovy_tips/#improved-groovy-dsl-support-in-your-ide","title":"Improved Groovy DSL support in your IDE","text":"<p>For more sophisticated script development, you can set up a project in your IDE with improved code assistance. You can use this alongside the debugger for a fully integrated development experience.</p> <p>This requires setting up a project with a dependency on <code>imposter-api.jar</code> and adding the GroovyDSL (GDSL) file.</p> <p>\u27a1\ufe0f See an example project</p> <p>If you just want to download the GDSL file see:</p> <p>\u27a1\ufe0f Download the GDSL file </p>"},{"location":"hbase_plugin/","title":"HBase plugin","text":"<ul> <li>Plugin name: <code>hbase</code></li> <li>Plugin class: <code>io.gatehill.imposter.plugin.hbase.HBasePluginImpl</code></li> </ul>"},{"location":"hbase_plugin/#features","title":"Features","text":"<ul> <li>Basic HBase mock implementation.</li> <li>Supports protobuf or JSON for wire transport.</li> <li>Dummy Scanner queries.</li> <li>Individual table row/record retrieval.</li> </ul>"},{"location":"hbase_plugin/#install-plugin","title":"Install plugin","text":""},{"location":"hbase_plugin/#option-1-using-the-cli","title":"Option 1: Using the CLI","text":"<p>To use this plugin, install it with the Imposter CLI:</p> <pre><code>imposter plugin install -d mock-hbase\n</code></pre> <p>This will install the plugin version matching the current engine version used by the CLI. The next time you run <code>imposter up</code>, the plugin will be available.</p>"},{"location":"hbase_plugin/#option-2-install-the-plugin-manually","title":"Option 2: Install the plugin manually","text":"<p>To use this plugin, download the <code>imposter-plugin-mock-hbase.jar</code> JAR file from the Releases page.</p> <p>Enable it with the following environment variables:</p> <pre><code>IMPOSTER_PLUGIN_DIR=\"/path/to/dir/containing/plugin\"\n</code></pre>"},{"location":"hbase_plugin/#using-the-plugin","title":"Using the plugin","text":"<p>Read the Configuration section to understand how to configure Imposter.</p> <p>Note: When using HBase Scanners, this plugin will return the 'server URL' in the <code>Location</code> header of the scanner creation response. You might want to consider setting the <code>serverUrl</code> property explicitly to the publicly-accessible address of the mock server, as described in the Usage section.</p>"},{"location":"hbase_plugin/#example","title":"Example","text":"<p>For working examples, see:</p> <pre><code>mock/hbase/src/test/resources/config\n</code></pre> <p>Let's assume your configuration is in a folder named <code>config</code>.</p> <p>CLI example:</p> <pre><code>imposter up ./config\n</code></pre> <p>Docker example:</p> <pre><code>docker run -ti -p 8080:8080 \\\n    -v $PWD/config:/opt/imposter/config \\\n    outofcoffee/imposter-all \\\n    --serverUrl http://localhost:8080\n</code></pre> <p>Standalone Java example:</p> <pre><code>java -jar distro/all/build/libs/imposter-all.jar \\\n    --configDir ./config \\\n    --serverUrl http://localhost:8080\n</code></pre> <p>This starts a mock server using the HBase plugin. Responses are served based on the configuration files inside the <code>config</code> folder.</p> <p>Using the example above, you can connect an HBase client, such as Apache RemoteHTable, to http://localhost:8080/ to interact with the API. In this example, you can interact with the <code>exampleTable</code> table, as defined in <code>hbase-plugin-config.json</code> and <code>hbase-plugin-data.json</code>.</p>"},{"location":"hbase_plugin/#additional-script-context-objects","title":"Additional script context objects","text":"<p>The following additional script context objects are available:</p> Object Type Description <code>tableName</code> <code>String</code> The name of the HBase table. <code>responsePhase</code> <code>io.gatehill.imposter.plugin.hbase.model.ResponsePhase</code> The type of response being served. <code>scannerFilterPrefix</code> <code>String</code> The prefix from the filter of the result scanner. <code>recordInfo</code> <code>io.gatehill.imposter.plugin.hbase.model.RecordInfo</code> Information about the requested record, if a single record is requested."},{"location":"interceptors/","title":"Interceptors","text":"<p>Interceptors are a useful way to execute logic early in the request-response process. They are executed before resources, allowing you to short-circuit a response, capture data or run a script to compute data for subsequent use in a resource. Interceptors are somewhat analogous to 'middleware' in Node.js/Express or Java Servlet interceptors.</p> <p>Interceptors match requests using the same matching rules as resources. This allows you to apply interceptors to particular requests.</p> <p>Multiple interceptors can be executed for a single request if they run in passthrough mode.</p>"},{"location":"interceptors/#short-circuit-a-response","title":"Short-circuit a response","text":"<p>Interceptors can respond to a request, short-circuiting the response and preventing resources from being served.</p> <p>For example, you might wish to check a property of the request, and respond with an HTTP 400 status if it does not match a particular value.</p> <pre><code>plugin: rest\n\ninterceptors:\n  - path: /*\n    requestHeaders:\n      User-Agent:\n        value: Some-User-Agent\n        operator: NotEqualTo\n    response:\n      statusCode: 400\n      content: Invalid user agent\n\nresources:\n  - path: /example\n    method: GET\n    response:\n      content: \"hello world\"\n</code></pre>"},{"location":"interceptors/#explanation","title":"Explanation","text":"<p>In this example, an interceptor runs on all requests (note the path <code>/*</code>) and responds with <code>HTTP 400</code> if the user agent request header does not match an expected value. Doing this in an interceptor avoids having to duplicate this check in each of the resources.</p>"},{"location":"interceptors/#passthrough","title":"Passthrough","text":"<p>Interceptors can run in 'passthrough' mode. Request processing continues after the interceptor has finished. This enables a resource to serve a response after an interceptor has completed its work.</p> <p>For example, you might want to capture a property of the request and make it available to all resources. You could also run a script to compute some data on each request before your resources serve a response.</p> <pre><code>plugin: rest\n\ninterceptors:\n  - path: /*\n    continue: true\n    capture:\n      theUserAgent:\n        requestHeader: \"user-agent\"\n\nresources:\n  - path: /example1\n    method: GET\n    response:\n      template: true\n      content: |\n        Example one\n        User agent: ${stores.request.theUserAgent}\n\n  - path: /example2\n    method: GET\n    response:\n      template: true\n      content: |\n        Example two\n        User agent: ${stores.request.theUserAgent}\n</code></pre>"},{"location":"interceptors/#explanation_1","title":"Explanation","text":"<p>In this example, an interceptor runs on all requests (note the path <code>/*</code>) and captures the user agent request header for use by the resources. Note the <code>continue: true</code> property in the interceptor. This indicates that request processing should continue to the <code>resources</code> after the interceptor has completed.</p> <p>The data captured by the interceptor is used by the resources in their response.</p>"},{"location":"interceptors/#multiple-interceptors","title":"Multiple interceptors","text":"<p>Multiple interceptors can be executed for a single request if they run in passthrough mode.</p> <pre><code>plugin: rest\n\ninterceptors:\n  - path: /*\n    continue: true\n    capture:\n      theUserAgent:\n        requestHeader: \"user-agent\"\n\n  - path: /*\n    steps:\n      - type: script\n        code: |\n          var req = stores.open(\"request\");\n          req.save(\"otherData\", \"foo\");\n          respond().continueToNext();\n\nresources:\n  - path: /example\n    method: GET\n    response:\n      template: true\n      content: |\n        User agent: ${stores.request.theUserAgent}\n        Other data: ${stores.request.otherData}\n</code></pre>"},{"location":"interceptors/#explanation_2","title":"Explanation","text":"<p>In this example, two interceptors execute for every request. The first sets the <code>continue: true</code> property, which indicates request processing should continue after it has completed.</p> <p>The second interceptor has a script step. Within the script, <code>respond().continueToNext()</code> is called, which has the same effect as setting <code>continue: true</code> in the configuration.</p> <p>Both interceptors store data, which is later used by the <code>/example</code> resource.</p>"},{"location":"interceptors/#examples","title":"Examples","text":"<p>See the following examples:</p> <ul> <li>See examples/rest/interceptors-simple for a short-circuit example.</li> <li>See examples/rest/interceptors-passthrough for a passthrough example.</li> </ul>"},{"location":"javascript_tips/","title":"JavaScript tips and tricks","text":""},{"location":"javascript_tips/#background","title":"Background","text":"<p>This section provides additional tips and tricks when using JavaScript as the scripting language for your mocks. It builds on the Scripting documentation. If you are new to Imposter scripting, it's best to start there.</p>"},{"location":"javascript_tips/#multi-file-javascript-scripts","title":"Multi-file JavaScript scripts","text":"<p>Sometimes you may want to split your JavaScript scripts into multiple files for better organisation. You can do this by using a bundler like Webpack or Browserify to bundle your scripts into a single file.</p> <p>See imposter-js-types for how to do this.</p> <p>Check out the samples directory for a JavaScript and a TypeScript example project.</p>"},{"location":"metrics_logs_telemetry/","title":"Metrics, health, logs and telemetry","text":""},{"location":"metrics_logs_telemetry/#status-endpoint","title":"Status endpoint","text":"<p>Imposter exposes a status endpoint under <code>/system/status</code></p> <p>This is useful as a healthcheck endpoint, such as for liveness or readiness checks.</p> <pre><code>$ curl http://localhost:8080/system/status\n\n{\n  \"status\":\"ok\",\n  \"version\":\"1.20.0\"\n}\n</code></pre>"},{"location":"metrics_logs_telemetry/#metrics","title":"Metrics","text":"<p>Imposter exposes telemetry using Prometheus under <code>/system/metrics</code></p> <p>This enables you to examine track various metrics, such as response time, error rates, total request count etc.</p> <pre><code>$ curl http://localhost:8080/system/metrics\n\n# HELP vertx_http_server_bytesReceived Number of bytes received by the server\n# TYPE vertx_http_server_bytesReceived summary\nvertx_http_server_bytesReceived_count 6.0\n\n# HELP vertx_http_server_requestCount_total Number of processed requests\n# TYPE vertx_http_server_requestCount_total counter\nvertx_http_server_requestCount_total{code=\"200\",method=\"GET\",} 5.0\n\n# HELP vertx_http_server_connections Number of opened connections to the server\n# TYPE vertx_http_server_connections gauge\nvertx_http_server_connections 2.0\n\n# HELP vertx_http_server_responseTime_seconds Request processing time\n# TYPE vertx_http_server_responseTime_seconds summary\nvertx_http_server_responseTime_seconds_count{code=\"200\",method=\"GET\",} 5.0\nvertx_http_server_responseTime_seconds_sum{code=\"200\",method=\"GET\",} 0.1405811\n\n# HELP vertx_http_server_responseTime_seconds_max Request processing time\n# TYPE vertx_http_server_responseTime_seconds_max gauge\nvertx_http_server_responseTime_seconds_max{code=\"200\",method=\"GET\",} 0.1039024\n</code></pre> <p>For example, to calculate the average response time, use the following PromQL:</p> <pre><code>vertx_http_server_responseTime_seconds_sum / vertx_http_server_responseTime_seconds_count\n</code></pre> <p>Other useful metrics:</p> Metric name Purpose response_file_cache_entries The number of cached response files script_execution_duration Script engine execution duration in seconds script_cache_entries The number of cached compiled scripts <p>Also see the metrics example.</p>"},{"location":"metrics_logs_telemetry/#logs","title":"Logs","text":"<p>Logs are printed to stdout.</p> <p>You can control the logging level using the following environment variable:</p> <pre><code># also supports WARN, INFO, DEBUG etc.\nexport IMPOSTER_LOG_LEVEL=\"TRACE\"\n</code></pre> <p>Internally, Log4J2 is used, so the usual configuration options apply.</p>"},{"location":"metrics_logs_telemetry/#structured-logging","title":"Structured logging","text":"<p>Imposter can log a JSON summary of each request, such as the following:</p> <pre><code>{\n  \"timestamp\" : \"2021-12-16T22:13:24.999Z\",\n  \"uri\" : \"http://localhost:8080/pets/1\",\n  \"path\" : \"/pets/1\",\n  \"method\" : \"GET\",\n  \"statusCode\" : \"200\",\n  \"scriptTime\" : \"30.80\",\n  \"duration\" : \"34.49\"\n}\n</code></pre> <p>To enable this, set the environment variable <code>IMPOSTER_LOG_SUMMARY=true</code>.</p>"},{"location":"metrics_logs_telemetry/#logging-requestresponse-headers","title":"Logging request/response headers","text":"<p>You can optionally include request and response headers in the JSON summary such as:</p> <pre><code>{\n  \"timestamp\" : \"2021-12-16T22:13:24.999Z\",\n  \"uri\" : \"http://localhost:8080/pets/1\",\n  \"path\" : \"/pets/1\",\n  \"method\" : \"GET\",\n  \"statusCode\" : \"200\",\n  \"scriptTime\" : \"350.80\",\n  \"duration\" : \"374.49\",\n  \"x-correlation-id\" : \"aabbcc12345\",\n  \"user-agent\" : \"Mozilla/5.0 (platform; rv:17.0) Gecko/geckotrail Firefox/90\",\n  \"content-length\" : \"123\"\n}\n</code></pre> <p>Note the presence of <code>x-correlation</code>, <code>user-agent</code> and <code>content-length</code> fields.</p> <p>To add these, set the following environment variables:</p> <pre><code>IMPOSTER_LOG_REQUEST_HEADERS=\"X-Correlation-ID,User-Agent\"\nIMPOSTER_LOG_RESPONSE_HEADERS=\"Content-Length\"\n</code></pre>"},{"location":"metrics_logs_telemetry/#logging-requestresponse-body","title":"Logging request/response body","text":"<p>You can optionally include the request and/or response body in the JSON summary.</p> <p>To enable these, set the following environment variables:</p> <pre><code>IMPOSTER_LOG_REQUEST_BODY=true\nIMPOSTER_LOG_RESPONSE_BODY=true\n</code></pre>"},{"location":"openapi_plugin/","title":"OpenAPI (and Swagger) plugin","text":"<ul> <li>Plugin name: <code>openapi</code></li> <li>Plugin class: <code>io.gatehill.imposter.plugin.openapi.OpenApiPluginImpl</code></li> </ul> <p>This plugin provides support for OpenAPI (and Swagger) specifications.</p>"},{"location":"openapi_plugin/#features","title":"Features","text":"<ul> <li>Creates mock endpoints from OpenAPI/Swagger v2 and OpenAPI v3 API specifications.</li> <li>Serves response examples embedded in the specification.</li> <li>Optionally validates your HTTP requests to ensure they match the OpenAPI specification.</li> <li>Supports custom responses, headers, status codes etc. based on path, querystring, request headers, request body and more.</li> <li>Also supports script-driven responses for maximum control, in either JavaScript or Groovy.</li> <li>Provides an interactive API sandbox at <code>/_spec</code></li> </ul>"},{"location":"openapi_plugin/#using-the-plugin","title":"Using the plugin","text":"<p>A great way to use this plugin is to take advantage of the built in <code>examples</code> feature of OpenAPI/Swagger files. These provide a standard way to document sample responses for each API response.</p> <p>This plugin will match the example to serve using a combination of:</p> <ul> <li>matching URI/path</li> <li>matching HTTP method</li> <li>matching content type in <code>Accept</code> HTTP request header to the <code>produces</code> property of the response</li> <li>matching status code to the response</li> </ul> <p>Imposter will return the first response found that matches the path and method. You can, of course, override the behaviour by setting the status code for a given combination of path and method (see below).</p> <p>Typically, you will use the configuration file <code>&lt;something&gt;-config.yaml</code> to override the status code, and thus the content of the response, however, you can use the in-built script engine to gain further control of the response data, headers etc. (see below). </p> <p>You can also use the interactive API sandbox at <code>/_spec</code>; e.g. http://localhost:8080/_spec, which looks like this:</p> <p></p>"},{"location":"openapi_plugin/#example","title":"Example","text":"<p>Here is an example configuration file:</p> <pre><code># petstore-config.yaml\n---\nplugin: openapi\nspecFile: petstore.yaml\n</code></pre> <p>In this example, we are using an OpenAPI specification file (<code>petstore.yaml</code>) containing the following API:</p> <pre><code>swagger: \"2.0\"\ninfo:\n  version: \"1.0.0\"\n  title: \"Swagger Petstore\"\nconsumes:\n  - \"application/json\"\nproduces:\n  - \"application/json\"\npaths:\n  /pets:\n    get:\n      description: \"Returns all pets from the system\"\n      produces:\n        - \"application/json\"\n      responses:\n        \"200\":\n          description: \"A list of pets.\"\n          schema:\n            type: \"array\"\n            items:\n              $ref: \"#/definitions/Pet\"\n          examples:\n            application/json: |-\n              [\n                {\n                  \"id\": 101,\n                  \"name\": \"Cat\"\n                },\n                {\n                  \"id\": 102,\n                  \"name\": \"Dog\"\n                }\n              ]\ndefinitions:\n  Pet:\n    type: \"object\"\n    required:\n      - \"id\"\n      - \"name\"\n    properties:\n      id:\n        type: \"integer\"\n        format: \"int64\"\n      name:\n        type: \"string\"\n</code></pre> <p>Some highlights:</p> <ul> <li>We\u2019ve defined the endpoint <code>/pets</code> as expecting an HTTP GET request</li> <li>We\u2019ve said it will produce JSON responses</li> <li>One response is defined for the HTTP 200 case</li> <li>We\u2019ve defined a data model in the definitions section</li> <li>We\u2019ve provided an example response \u2014 the same JSON array described earlier</li> </ul>"},{"location":"openapi_plugin/#start-imposter-with-the-openapi-plugin","title":"Start Imposter with the OpenAPI plugin","text":"<p>The OpenAPI plugin is bundled with the core Imposter distribution.</p> <p>Let's assume your configuration is in the directory: <code>examples/openapi/simple</code>. Here are a few ways to start a mock running on port 8080.</p> <p>CLI example:</p> <pre><code>imposter up ./examples/openapi/simple\n</code></pre> <p>Docker example:</p> <pre><code>docker run --rm -ti -p 8080:8080 \\\n    -v $PWD/examples/openapi/simple:/opt/imposter/config \\\n    outofcoffee/imposter\n</code></pre> <p>Java JAR example:</p> <pre><code>java -jar distro/core/build/libs/imposter-core.jar \\\n    --configDir ./examples/openapi/simple\n</code></pre> <p>This starts a mock server using the OpenAPI plugin. Responses are served based on the OpenAPI specification <code>petstore.yaml</code>.</p> <p>Using the example above, you can interact with the APIs with examples in the Swagger specification at their respective endpoints under <code>http://localhost:8080/&lt;endpoint path&gt;</code>.</p> <p>Send an HTTP request to the <code>/pets</code> path defined in the configuration file to see the example response:</p> <pre><code>$ curl -v \"http://localhost:8080/pets\"\n...\nHTTP/1.1 200 OK\n...\n[\n  {\n    \"id\": 101,\n    \"name\": \"Cat\"\n  },\n  {\n    \"id\": 102,\n    \"name\": \"Dog\"\n  }\n]\n</code></pre> <p>For specific information about the endpoints, see the interactive sandbox at http://localhost:8080/_spec.</p> <p>Once you're finished, stop the server with CTRL+C.</p> <p>For more working examples, see:</p> <ul> <li>examples/openapi</li> </ul>"},{"location":"openapi_plugin/#validating-requests-against-the-specification","title":"Validating requests against the specification","text":"<p>Imposter allows you to validate your HTTP requests to ensure they match the OpenAPI specification.</p> <p>To enable this, set the <code>validation.request</code> configuration option to <code>true</code>:</p> <pre><code># validating-request-config.yaml\n---\nplugin: \"openapi\"\nspecFile: \"example-spec.yaml\"\n\nvalidation:\n  request: true\n</code></pre> <p>Now, for every incoming request to a valid combination of path and HTTP method, Imposter will validate the request parameters, headers and body against the corresponding part of the specification.</p> <p>If a request fails validation, Imposter logs the validation errors then responds with an HTTP 400 status and, optionally, a report of the errors.</p> <p>For example, let's make an HTTP request to an endpoint whose specification requires a request body and also requires a header, named 'X-Correlation-ID':</p> <pre><code>$ curl -v -X POST http://localhost:8080/pets\n</code></pre> <p>Note that our request does not provide either a request body or header.</p> <p>This results in the following log entries:</p> <pre><code>WARN  i.g.i.p.o.s.SpecificationServiceImpl - Validation failed for POST /pets: Validation failed.\n[ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request.\n[ERROR][REQUEST][POST /pets @body] A request body is required but none found.\n</code></pre> <p>...and the following HTTP response:</p> <pre><code>HTTP/1.1 400 Bad Request\nContent-Type: text/plain\nContent-Length: 261\n\nRequest validation failed:\n[ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request.\n[ERROR][REQUEST][POST /pets @body] A request body is required but none found.\n</code></pre> <p>This is because in the corresponding part of the OpenAPI specification, both the header and request body are marked as required.</p> <p>Note that if the request body were provided, its structure would be validated against the corresponding schema entry.</p> <p>For more information about validation, including how to ignore certain conditions, see the OpenAPI validation document.</p>"},{"location":"openapi_plugin/#overriding-status-code","title":"Overriding status code","text":"<p>Sometimes you might want to force a particular status code to be returned, or use other specific behaviours. To do this, you can use the <code>resources</code> configuration:</p> <pre><code># override-status-code-config.yaml\n---\nplugin: \"openapi\"\nspecFile: \"spec-with-multiple-status-codes.yaml\"\n\nresources:\n  - path: \"/pets\"\n    method: post\n    response:\n      statusCode: 201\n\n  - path: \"/pets/{petId}\"\n    method: put\n    response:\n      statusCode: 202\n</code></pre> <p>Here, POST requests to the <code>/pets</code> endpoint will default to the HTTP 201 status code. If there is a corresponding response example for the 201 status, this will be returned in the HTTP response.</p> <p>The <code>path</code> property supports placeholders using the usual OpenAPI <code>{placeholder}</code> format, so in the second example above, PUT requests to the endpoint <code>/pets/&lt;some ID&gt;</code> will return a 202 status. Any placeholder names in paths in the plugin configuration file must match the ones used in the OpenAPI schema.</p>"},{"location":"openapi_plugin/#return-a-specific-example","title":"Return a specific example","text":"<p>You can make Imposter select a specific example to use as the response body.</p> <pre><code># override-examples-config.yaml\n---\nplugin: \"openapi\"\nspecFile: \"spec-with-multiple-examples.yaml\"\n\nresources:\n  - path: /pets/1\n    method: get\n    response:\n      exampleName: catExample\n\n  - path: /pets/2\n    method: get\n    response:\n      exampleName: dogExample\n</code></pre>"},{"location":"openapi_plugin/#return-a-custom-response","title":"Return a custom response","text":"<p>You can also specify a static response file to use instead of an example:</p> <pre><code># ... as above ...\n\n  - path: /pets/3\n    method: get\n    response:\n      file: tortoise.json\n      statusCode: 200\n</code></pre>"},{"location":"openapi_plugin/#return-a-literal-string","title":"Return a literal string","text":"<p>You can also specify a literal string to return as the response body:</p> <pre><code># ... as above ...\n\n  - path: /pets/4\n    method: get\n    response:\n      content: '{ \"foo\": \"bar\" }'\n</code></pre>"},{"location":"openapi_plugin/#conditional-responses","title":"Conditional responses","text":"<p>You can control response behaviour based on the value of query parameters, path parameters, headers or body content.</p> <pre><code># override-examples-config.yaml\n---\nplugin: \"openapi\"\nspecFile: \"spec-with-multiple-status-codes.yaml\"\n\nresources:\n  # return HTTP 200 if request includes query parameter 'foo=bar'\n  - path: \"/pets\"\n    method: \"get\"\n    queryParams:\n      foo: bar\n    response:\n      statusCode: 200\n\n  # default to HTTP 400 response\n  - path: \"/pets\"\n    method: \"get\"\n    response:\n      statusCode: 400\n</code></pre>"},{"location":"openapi_plugin/#first-example","title":"First example","text":"<p>Here we expect an HTTP 200 status code, given the matching query string.</p> <pre><code>$ curl -v -X POST http://localhost:8080/pets?foo=bar\nHTTP/1.1 200 OK\n</code></pre>"},{"location":"openapi_plugin/#second-example","title":"Second example","text":"<p>Here we expect an HTTP 400 status code.</p> <pre><code>$ curl -v -X POST http://localhost:8080/pets\nHTTP/1.1 400 Bad Request\n</code></pre>"},{"location":"openapi_plugin/#object-response-examples","title":"Object response examples","text":"<p>Imposter has basic support for response examples defined as objects, for example an API specification like <code>object-examples.yaml</code> - see examples/openapi/object-examples.</p> <p>The salient part of the response is as follows:</p> <pre><code>responses:\n  \"200\":\n    description: team response\n    schema:\n      type: object\n      items:\n        $ref: '#/definitions/Team'\n    examples:\n      application/json:\n        id: 10\n        name: Engineering\n</code></pre> <p>Note that the example is specified as an object, rather than literal JSON.</p> <p>Imposter currently supports JSON and YAML serialised content types in the response if they are specified in this way. If you want to return a different format, return a literal string, such as those above.</p>"},{"location":"openapi_plugin/#setting-a-path-prefix","title":"Setting a path prefix","text":"<p>It is possible to set a prefix for the paths within an OpenAPI specification. This is helpful to avoid clashes when including more than one specification containing identical paths. To set the prefix, use the <code>path</code> property at the top of the configuration file.</p> <p>For example, to add the prefix <code>/example</code> before each path within the OpenAPI specification <code>spec.yaml</code>, set the <code>path</code> in your configuration file:</p> <pre><code># imposter-config.yaml\n---\nplugin: openapi\nspecFile: spec.yaml\n\n# set a prefix for all paths in the spec above\npath: /example\n</code></pre> <p>Given an OpenAPI specification such as:</p> <pre><code># spec.yaml\n---\nopenapi: \"3.0.0\"\n# ... info etc. omitted for brevity\n\npaths:\n  /pets/{petId}:\n    # ...operation details\n</code></pre> <p>...then the path <code>/pets/{petId}</code> would be accessible at the path:</p> <pre><code>/example/pets/{petId}\n</code></pre>"},{"location":"openapi_plugin/#interaction-of-openapi-servers-and-imposter-basepath","title":"Interaction of OpenAPI <code>servers</code> and Imposter <code>basePath</code>","text":"<p>If an OpenAPI specification lists <code>servers</code> with URLs containing a path, then matching of resources in the Imposter configuration file relies upon setting the Imposter <code>basePath</code> property.</p> <p>For example, if the first server entry in the OpenAPI specification had a URL set to <code>https://example.com/api</code>, then the Imposter <code>basePath</code> should be <code>/api</code>.</p> <p>Similarly, if the OpenAPI server URL were set to <code>/api</code>, then the Imposter <code>basePath</code> should be <code>/api</code>.</p> <p>Note that only the first server entry in the OpenAPI <code>servers</code> array is examined for its path.</p>"},{"location":"openapi_plugin/#scripted-responses-advanced","title":"Scripted responses (advanced)","text":"<p>For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts.</p> <p>See the Scripting section for more information.</p> <p>For a simple script, see examples/openapi/scripted-named-example for a working example.</p>"},{"location":"openapi_plugin/#additional-context-objects","title":"Additional context objects","text":"<p>This plugin adds objects to the script <code>context</code>:</p> Object Type Description <code>operation</code> <code>io.swagger.v3.oas.models.Operation</code> The OpenAPI operation for the request."},{"location":"openapi_plugin/#example_1","title":"Example","text":"<p>Here we set the <code>response.scriptFile</code> property in the configuration file:</p> <pre><code># scripted-openapi-config.yaml\n---\nplugin: openapi\nspecFile: petstore.yaml\nresponse:\n  scriptFile: example.groovy\n</code></pre> <p>As a reminder, you can use either JavaScript (<code>.js</code>) or Groovy (<code>.groovy</code>) languages for your scripts.</p> <p>Now, <code>example.groovy</code> can control the responses, such as:</p> <ol> <li>a specific OpenAPI example name to return</li> </ol> <pre><code>respond().withExampleName('example1')\n</code></pre> <ol> <li>the content of a file to return</li> </ol> <pre><code>respond().withFile('some-file.json')\n</code></pre> <ol> <li>a literal string to return</li> </ol> <pre><code>respond().withContent('{ \"foo\": \"bar\" }')\n</code></pre>"},{"location":"openapi_plugin/#returning-a-named-example","title":"Returning a named example","text":"<p>OpenAPI specifications allow API authors to provide examples of requests, responses, parameters and schema items.</p> <p>You can return a specific named example from the specification in your script using the <code>withExampleName(String)</code> method.</p> <pre><code>if (context.request.pathParams.petId == '2') {\n    respond().withExampleName('dogExample')\n}\n</code></pre> <p>This selects the example from the OpenAPI <code>examples</code> section for the API response.</p> <pre><code>paths:\n  /pets/{petId}:\n    get:\n      # (...some parts of operation excluded for brevity)\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pet\"\n              examples:\n                # the example to return is selected by the script\n                catExample:\n                  value:\n                    { \"id\": 1, \"name\": \"Cat\" }\n                dogExample:\n                  value:\n                    { \"id\": 2, \"name\": \"Dog\" }\n</code></pre>"},{"location":"openapi_plugin/#examples","title":"Examples","text":"<ul> <li>scripted-named-example</li> <li>scripted-named-example-js</li> <li>static-named-example</li> </ul>"},{"location":"openapi_plugin/#configuration-reference","title":"Configuration reference","text":"<p>In addition to the standard configuration file options, the following additional properties are supported.</p> Configuration name Purpose Default value <code>isPickFirstIfNoneMatch</code> (Optional) If no exact match is found for an example in a operation, based on matching name to accepted content types, choose the first item found from specification. <code>false</code> <code>path</code> (Optional) A string to prepend to each operation's path. Empty <code>specFile</code> (Required) path to OpenAPI specification file (see below). Empty <code>stripServerPath</code> (Optional) Whether to remove the path component from the OpenAPI <code>servers</code> entries from the mock resource paths. <code>false</code> <code>validation</code> (Optional) Controls request validation - see Validation. Empty"},{"location":"openapi_plugin/#openapi-specification-locations","title":"OpenAPI specification locations","text":"<p>OpenAPI files can be provided as a relative file, an HTTP(S) URL or a file in an S3 bucket.</p> <p>Some examples:</p> <p>A file in the same directory as the configuration file:</p> <pre><code>plugin: openapi\nspecFile: sample_spec.yaml\n</code></pre> <p>At a URL:</p> <pre><code>plugin: openapi\nspecFile: https://example.com/sample_spec.yaml\n</code></pre> <p>In an S3 bucket:</p> <pre><code>plugin: openapi\nspecFile: s3://example-bucket/sample_spec.yaml\n</code></pre> <p>When using S3, set up your AWS profile/region/credentials as per standard AWS practice. For example, using an instance profile in EC2, environment variables or the various local environment configuration locations for providing AWS credentials. </p> <p>Note: Remote specification files can be cached locally by setting the environment variable <code>IMPOSTER_OPENAPI_REMOTE_FILE_CACHE=true</code>.</p>"},{"location":"openapi_validation/","title":"OpenAPI request validation","text":"<p>This document describes how to validate HTTP requests against an OpenAPI specification when using the OpenAPI plugin.</p>"},{"location":"openapi_validation/#validating-requests-against-the-specification","title":"Validating requests against the specification","text":"<p>Imposter allows you to validate your HTTP requests to ensure they match the OpenAPI specification.</p> <p>To enable this, set the <code>validation.request</code> configuration option to <code>true</code>:</p> <pre><code># validating-request-config.yaml\n---\nplugin: \"openapi\"\nspecFile: \"example-spec.yaml\"\n\nvalidation:\n  request: true\n</code></pre> <p>Now, for every incoming request to a valid combination of path and HTTP method, Imposter will validate the request parameters, headers and body against the corresponding part of the specification.</p> <p>If a request fails validation, Imposter logs the validation errors then responds with an HTTP 400 status and, optionally, a report of the errors.</p> <p>For example, let's make an HTTP request to an endpoint whose specification requires a request body and also requires a header, named 'X-Correlation-ID':</p> <pre><code>$ curl -v -X POST http://localhost:8080/pets\n</code></pre> <p>Note that our request does not provide either a request body or header.</p> <p>This results in the following log entries:</p> <pre><code>WARN  i.g.i.p.o.s.SpecificationServiceImpl - Validation failed for POST /pets: Validation failed.\n[ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request.\n[ERROR][REQUEST][POST /pets @body] A request body is required but none found.\n</code></pre> <p>...and the following HTTP response:</p> <pre><code>HTTP/1.1 400 Bad Request\nContent-Type: text/plain\nContent-Length: 261\n\nRequest validation failed:\n[ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request.\n[ERROR][REQUEST][POST /pets @body] A request body is required but none found.\n</code></pre> <p>This is because in the corresponding part of the OpenAPI specification, both the header and request body are marked as required:</p> <pre><code>/pets/{petId}:\n  put:\n    summary: Update a specific pet\n    operationId: updatePet\n    parameters:\n      - in: path\n        name: petId\n        required: true\n    requestBody:\n      required: true\n      content:\n        application/json:\n          schema:\n            $ref: \"#/components/schemas/Pet\" \n</code></pre> <p>Note that if the request body were provided, its structure would be validated against the corresponding schema entry.</p> <p>See examples/openapi/request-validation for a working example.</p>"},{"location":"openapi_validation/#configuring-issue-behaviour","title":"Configuring issue behaviour","text":"<p>When validation issues occur, the possible behaviours are:</p> <ul> <li>fail the request (<code>fail</code> or <code>true</code>)</li> <li>log only (<code>log</code>)</li> <li>ignore (<code>ignore</code> or <code>false</code>)</li> </ul>"},{"location":"openapi_validation/#fail-the-request","title":"Fail the request","text":"<pre><code># fail the request if validation issues occur\nvalidation:\n  request: fail\n</code></pre>"},{"location":"openapi_validation/#log-only","title":"Log only","text":"<pre><code># just log if validation issues occur\nvalidation:\n  request: log\n</code></pre>"},{"location":"openapi_validation/#ignore","title":"Ignore","text":"<pre><code># ignore validation issues\nvalidation:\n  request: ignore\n</code></pre> <p>If the <code>validation</code> block is not specified, validation issue behaviour is controlled by the <code>IMPOSTER_OPENAPI_VALIDATION_DEFAULT_BEHAVIOUR</code> environment variable. The default value is <code>ignore</code>. Possible values are the same as the configuration file (above).</p>"},{"location":"openapi_validation/#configuring-validation-levels","title":"Configuring validation levels","text":"<p>You can control which validation checks are considered errors, and which are ignored.</p> <p>To do this, use the <code>validation.levels</code> section, for example:</p> <pre><code># validating-request-config.yaml\n---\nplugin: \"openapi\"\nspecFile: \"example-spec.yaml\"\n\nvalidation:\n  request: true\n  levels:\n    validation.request.body.missing: WARN\n    validation.request.security.invalid: ERROR\n</code></pre> <p>In the example above, if the request body were missing, Imposter would not treat this as a validation error.</p> <p>The <code>validation.levels</code> block is a map of validation key (i.e. a type of validation check) to level (<code>ERROR</code> or <code>WARN</code>).</p> <p>See the full list of validations at the swagger-request-validator-core project.</p>"},{"location":"performance_simulation/","title":"Performance simulation","text":"<p>Characteristics like response latency can be simulated.</p>"},{"location":"performance_simulation/#injecting-delays","title":"Injecting delays","text":"<p>Delays can be injected via configuration or using a script driven approach. Delays are specified in milliseconds.</p> <p>The delay controls the time added after any request processing has completed (scripts, plugins etc.). So, if a normal un-delayed request takes 0.05 seconds and a delay of 100ms is added, then the response will be transmitted to the client after 105ms.</p> <p>Delays can be specified as an exact value, or a range. If a range is specified, then a random value (roughly uniformly distributed) will be selected between the minimum and maximum range values.</p> <p>Note Delays can also be combined with failure simulation effects. For example to simulate a delay followed by a closed connection.</p>"},{"location":"performance_simulation/#configuration-driven","title":"Configuration driven","text":"<p>Specify the <code>delay</code> section in configuration:</p> <p>For the root resource:</p> <pre><code># ...\n\nresponse:\n  statusCode: 200\n  file: \"response.json\"\n\n  # exactly 1000ms delay\n  delay:\n    exact: 1000\n</code></pre> <p>For a specific resource (e.g. OpenAPI or REST plugin):</p> <pre><code># ...\n\nresources:\n  - method: GET\n    path: /example\n    response:\n      statusCode: 200\n      file: \"response.json\"\n\n      # delay in range of 500ms-1500ms\n      delay:\n        min: 500\n        max: 1500\n</code></pre>"},{"location":"performance_simulation/#script-driven","title":"Script driven","text":"<p>If using Scripting, use the <code>withDelay(exactDelay)</code> and <code>withDelayRange(minDelay, maxDelay)</code> methods.</p> <p>For an exact delay:</p> <pre><code>respond()\n    .withStatusCode(200)\n    .withFile('response.json')\n    .withDelay(1000)\n</code></pre> <p>For a delay within a range:</p> <pre><code>respond()\n    .withStatusCode(200)\n    .withFile('response.json')\n    .withDelayRange(500, 1500)\n</code></pre>"},{"location":"performance_simulation/#logs","title":"Logs","text":"<p>You will see log entries similar to the following:</p> <pre><code>14:39:08 INFO  i.g.i.s.ResponseServiceImpl - \n  Delaying mock response for GET /example-range-delay by 1000ms\n\n14:39:09 INFO  i.g.i.s.ResponseServiceImpl - \n  Serving response data (5 bytes) for URI http://localhost:50203/example-range-delay with status code 200\n</code></pre>"},{"location":"performance_tuning/","title":"Performance tuning","text":"<p>Imposter supports hundreds to thousands of requests per second, on a single CPU core and small memory footprint.</p> <p>See Benchmarks for representative performance tests.</p>"},{"location":"performance_tuning/#tuning","title":"Tuning","text":"<p>Some Imposter features have a greater impact than others on the performance of the mock engine.</p>"},{"location":"performance_tuning/#turning-off-features","title":"Turning off features","text":"<p>Switching off features helps further reduce the memory and CPU requirements of the mock engine.</p> <p>Features that can be switched off include:</p> <ul> <li>stores</li> <li>metrics collection</li> </ul> <p>See features and usage documentation.</p>"},{"location":"performance_tuning/#resource-matching-performance","title":"Resource matching performance","text":"<p>Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath or XPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance. </p>"},{"location":"performance_tuning/#response-templating-performance","title":"Response Templating performance","text":"<p>Templating incurs a performance penalty, but is often faster than dynamically generating large objects using scripts, so is generally a better tradeoff when dynamic responses are required.</p> <p>Template files are cached in memory once read from disk, so they do not incur as high an I/O cost from storage on subsequent requests.</p> <p>Using JsonPath in placeholder templates is computationally expensive, as it requires parsing and querying of an item rather than just value substitution.</p>"},{"location":"performance_tuning/#data-capture-performance","title":"Data Capture performance","text":"<p>Data capture incurs overhead on response times, depending on the speed of the store implementation used. If using the in-memory store, the performance impact is lower than using an external store. For store providers backed by external datastores, requests will incur a synchronous write to the store when capturing data.</p> <p>You might consider using deferred capture, which has the advantage of improving request throughput, at the cost of persistence occurring after the request has been completed.</p> <p>Using JsonPath to capture the request body is computationally expensive, as it requires parsing and querying of the request body item rather than just copying a reference.</p>"},{"location":"performance_tuning/#bundle-your-configuration","title":"Bundle your configuration","text":"<p>When deploying Imposter, a common pattern is to store configuration in an external store, such as a storage bucket. Whilst this model has some deployment benefits, retrieving external configuration can cause slower startup times.</p> <p>In a serverless environment, where compute instances are short-lived, this can cause scaling challenges due to longer cold start times. Therefore, in highly dynamic environments, such as containers or serverless functions, startup time can be improved by avoiding configuration retrieval whenever an instance of the mock engine is started.</p> <p>Imposter supports a deployment model called 'Bundled Configuration'. In this model, the mock configuration is included alongside the mock engine in the same package. When the engine starts, configuration is local to the instance of the engine, avoiding the time taken for retrieval. </p> <p>See the Bundled Configuration section of the Deployment patterns documentation.</p>"},{"location":"performance_tuning/#benchmarks","title":"Benchmarks","text":"<p>See Benchmarks for representative performance tests, including test set up and configuration.</p>"},{"location":"plugins/","title":"Plugins","text":"<p>Imposter uses plugins to control its behaviour and provide specialised mocks.</p> <p>You can also write your own plugins, if you want to customise behaviour further.</p> <p>The following table describes the available plugins.</p> Category Plugin name Description Details Mock <code>hbase</code> HBase mocks. See HBase plugin. Mock <code>openapi</code> OpenAPI (and Swagger) mocks. Built-in. See OpenAPI (and Swagger) plugin. Mock <code>rest</code> REST mocks. Built-in. See REST plugin. Mock <code>sfdc</code> SFDC (Salesforce) mocks. See SFDC (Salesforce) plugin. Mock <code>soap</code> SOAP (and WSDL) mocks. Built-in. See SOAP plugin. Mock <code>wiremock</code> WireMock mappings support. See WireMock plugin. Scripting <code>js-graal</code> Graal.js scripting. Graal.js JavaScript scripting support. This is the default JavaScript script engine. See Modern JavaScript features. Scripting <code>js-nashorn</code> Nashorn scripting. This is the legacy JavaScript script engine Store <code>store-dynamodb</code> DynamoDB store implementation. See DynamoDB store. Store <code>store-redis</code> Redis store implementation. See Redis store. Store <code>store-graphql</code> GraphQL store queries. See GraphQL. Configuration <code>config-detector</code> Detects plugins from <code>*-config</code> files. Built-in Configuration <code>meta-detector</code> Detects plugins from <code>META-INF</code>. Built-in Data generator <code>fake-data</code> Generates fake data. See Fake data generator."},{"location":"plugins/#plugin-loading","title":"Plugin loading","text":"<p>Imposter loads plugins from the plugin directory. This is configured using the following environment variable:</p> <pre><code>IMPOSTER_PLUGIN_DIR=\"/path/to/dir/containing/plugin\"\n</code></pre> <p>When you set this environment variable, plugin JAR files placed in this directory will be loaded by Imposter on startup.</p>"},{"location":"plugins/#using-the-cli","title":"Using the CLI","text":"<p>If you are using the Imposter CLI, you can install a plugin with:</p> <pre><code>imposter plugin install -d &lt;plugin name&gt;\n</code></pre> <p>The CLI automatically manages the plugin directory, so you do not have to set the <code>IMPOSTER_PLUGIN_DIR</code> environment variable.</p> <p>For example:</p> <pre><code>imposter plugin install -d stores-dynamodb\n</code></pre> <p>This will install the plugin version matching the current engine version used by the CLI. The next time you run <code>imposter up</code>, the plugin will be available.</p>"},{"location":"plugins/#using-the-docker-image","title":"Using the Docker image","text":"<p>If you are using the Docker image, you can bind-mount a local directory to the <code>/opt/imposter/plugins</code> directory within the container.</p> <p>For example:</p> <pre><code>docker run --rm -it \\\n    -v /path/to/plugin/dir:/opt/imposter/plugins \\\n    -v /path/to/config/dir:/opt/imposter/config \\\n    -p 8080:8080 \\\n    outofcoffee/imposter\n</code></pre> <p>The Docker container sets the environment variable <code>IMPOSTER_PLUGIN_DIR=/opt/imposter/plugins</code>, so you do not have to set it explicitly.</p>"},{"location":"proxy_endpoint/","title":"Proxy an existing endpoint","text":"<p>Imposter can generate mock configuration files for you by proxying an existing endpoint.</p> <p>If you don't have an existing endpoint to proxy, it's easy to create the configuration using the guide.</p>"},{"location":"proxy_endpoint/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install the Imposter CLI</li> <li>An API/endpoint you wish to mock</li> </ul>"},{"location":"proxy_endpoint/#steps","title":"Steps","text":"<p>Let's imagine you want to proxy an endpoint running at <code>http://localhost:3000</code>. For simplicity, we will imagine it returns the following data:</p> <pre><code>$ curl http://localhost:3000\n\n{ \"petType\": \"Cat\", \"petName\": \"Fluffy\" }\n</code></pre> <p>Imposter can create a mock for you by acting as a proxy, capturing the request and responses as they are made.</p>"},{"location":"proxy_endpoint/#create-a-mock","title":"Create a mock","text":"<p>Start Imposter as a proxy:</p> <pre><code>$ imposter proxy http://localhost:3000\n\nstarting proxy for upstream http://localhost:3000 on port 8080\n</code></pre> <p>Imposter has started an HTTP server on port 8080. Any requests sent to <code>http://localhost:8080</code> will be forwarded to the upstream endpoint. Responses from the upstream will be recorded, then returned to the client. </p> <p>Now call the endpoint via the proxy:</p> <pre><code>$ curl http://localhost:8080\n\n{ \"petType\": \"Cat\", \"petName\": \"Fluffy\" }\n</code></pre> <p>You'll notice the response from the upstream endpoint is still returned, but in addition, Imposter captured the important parts of the request and response for you.</p> <pre><code>received request GET / from client 127.0.0.1:53446\ninvoking upstream http://localhost:3000 with GET / [body: 0 bytes]\nupstream responded to GET http://localhost:3000/ with status 200 [body 43 bytes]\nwrote response [status: 200, body 43 bytes] to client 127.0.0.1:53446\nproxied GET / to upstream [status: 200, body 43 bytes] for client 127.0.0.1:53446 in 1.82875ms\nwrote response file /Users/mary/example/GET-index.json for GET /index.json [43 bytes]\nwrote config file /Users/mary/example/localhost-3000-config.yaml for GET /index.json\n</code></pre> <p>Look in the directory where you started Imposter and you will see two new files:</p> <pre><code>$ ls -l\n-rw-r--r--  1 mary  wheel    43B  8 Sep 13:56 GET-index.json\n-rw-r--r--  1 mary  wheel   171B  8 Sep 13:56 localhost-3000-config.yaml\n</code></pre> <p>The <code>GET-index.json</code> file contains the response body above. The <code>localhost-3000-config.yaml</code> is the Imposter configuration file.</p>"},{"location":"proxy_endpoint/#testing-the-mock","title":"Testing the mock","text":"<p>Now we have our configuration and response files, we can stop the proxy and just use the mock.</p> <p>Stop Imposter using <code>CTRL+C</code>.</p> <p>In the same directory as the files you captured above, start Imposter:</p> <pre><code>$ imposter up\n\nStarting mock engine 3.0.4\nLoading configuration file: /opt/imposter/config/localhost-3000-config.yaml\nAdding handler: GET -&gt; /\nMock engine up and running on http://localhost:8080\n</code></pre> <p>Imposter read the configuration files and a mock of the original endpoint is now running at <code>http://localhost:8080</code></p> <p>Call the mock:</p> <pre><code>$ curl http://localhost:8080\n\n{ \"petType\": \"Cat\", \"petName\": \"Fluffy\" }\n</code></pre> <p>Imposter served the response based on what it captured.</p> <pre><code>Matched resource config for GET http://localhost:8080/\nServing response file GET-index.json for GET http://localhost:8080/ with status code 200\n</code></pre>"},{"location":"proxy_endpoint/#examine-the-mock","title":"Examine the mock","text":"<p>You can examine your mock by looking at the configuration file:</p> <pre><code># localhost-3000-config.yaml\n---\nplugin: rest\nresources:\n- method: GET\n  path: /\n  response:\n    file: GET-index.json\n    statusCode: 200\n    headers:\n      Content-Type: application/json\n</code></pre> <p>Some things to note:</p> <ul> <li>The HTTP method and path from the request have been recorded by the proxy</li> <li>The <code>file: GET-index.json</code> property refers to the JSON file representing the captured response body</li> <li>The response header (<code>Content-Type: application/json</code>) was also recorded</li> </ul> <p>For completeness, see the contents of the response file reflect the content of the response body from the upstream endpoint:</p> <pre><code>{ \"petType\": \"Cat\", \"petName\": \"Fluffy\" }\n</code></pre>"},{"location":"proxy_endpoint/#making-changes","title":"Making changes","text":"<p>You can, of course, edit the configuration file so the mock behaves differently. When you change either the configuration file or response file, the Imposter CLI will restart to reflect your latest changes.</p>"},{"location":"proxy_endpoint/#capture-request-body-and-headers","title":"Capture request body and headers","text":"<p>It's possible to capture the request body and/or request headers using the following flags:</p> <pre><code>--capture-request-body\n</code></pre> <p>and</p> <pre><code>--capture-request-headers\n</code></pre> <p>For example:</p> <pre><code>imposter proxy http://example.com --capture-request-body --capture-request-headers\n</code></pre>"},{"location":"proxy_endpoint/#whats-next","title":"What's next","text":"<p>Learn how to use Imposter with the Configuration guide.</p>"},{"location":"request_matching/","title":"Advanced request matching","text":"<p>You can match resources to requests using attributes such as the HTTP method, path, query string, headers or body. For JSON and XML request bodies, JsonPath and XPath can also be used, respectively.</p>"},{"location":"request_matching/#match-operators","title":"Match operators","text":"<p>Matchers support a number of operators to control how the match is performed.</p> <p>For example:</p> <pre><code>resources:\n- method: GET\n  path: /example\n  requestHeaders:\n    content-type:\n      value: somevalue\n      operator: Contains\n  response:\n    statusCode: 400\n</code></pre> <p>The following operators are supported:</p> Operator Description <code>EqualTo</code> Checks if the expression result equals the <code>value</code>. <code>NotEqualTo</code> Checks if the expression result does not equal the <code>value</code>. <code>Exists</code> Checks if the expression result is not <code>null</code> or absent. <code>NotExists</code> Checks if the expression result is <code>null</code> or absent. <code>Contains</code> Checks if the expression result contains the <code>value</code>. <code>NotContains</code> Checks if the expression result does not contain the <code>value</code>. <code>Matches</code> Checks if the expression result matches the regular expression specified in the <code>value</code> field. <code>NotMatches</code> Checks if the expression result does not match the regular expression specified in the <code>value</code> field. <p>Note If no <code>operator</code> is specified, then <code>EqualTo</code> is used.</p>"},{"location":"request_matching/#matching-against-http-method-path-query-string-or-headers","title":"Matching against HTTP method, path, query string or headers","text":"<p>See Configuration for simple matching against HTTP method, path, query string or headers.</p> <p>If you need more complex matching, you can use the 'long form' configuration, which allows you to specify a match expression and operator for each attribute.</p> <p>For example:</p> <pre><code>resources:\n- method: GET\n  path: /example\n  requestHeaders:\n    content-type:\n      value: somevalue\n      operator: Contains\n  response:\n    statusCode: 400\n</code></pre> <p>Request matchers support the range of operators described in this document.</p>"},{"location":"request_matching/#matching-against-the-request-body","title":"Matching against the request body","text":"<p>You can also match a resource based on the request body. For JSON and XML request bodies, JsonPath and XPath can also be used, respectively.</p>"},{"location":"request_matching/#matching-a-json-request-body","title":"Matching a JSON request body","text":"<p>You can match a resource based on a JsonPath query of a JSON request body.</p> <p>Only JSON request bodies are supported for the feature.</p> <p>Specify the match configuration using the <code>requestBody.jsonPath</code> property of a resource.</p> <p>Here you specify a JsonPath expression, and the value it must match.</p> <p>For example:</p> <pre><code>resources:\n- method: GET\n  path: /example1\n  requestBody:\n    jsonPath: $.foo\n    value: bar\n  response:\n    statusCode: 204\n</code></pre> <p>This example will match a request body like this:</p> <pre><code>{ \"foo\": \"bar\" }\n</code></pre> <p>Any of the match operators, such as <code>Contains</code>, <code>Matches</code> etc. can be used in a JsonPath matcher.</p>"},{"location":"request_matching/#unmatched-or-null-jsonpath-expressions","title":"Unmatched or null JsonPath expressions","text":"<p>If the result of evaluating the JsonPath expression is <code>null</code> or if the path evaluates to non-existent property in the body, then it is considered <code>null</code>.</p> <p>You can explicitly match a <code>null</code> value, as follows:</p> <pre><code>resources:\n- method: GET\n  path: /example2\n  requestBody:\n    jsonPath: $.not-matching-example\n    value: null\n  response:\n    statusCode: 409\n</code></pre> <p>Note: the YAML keyword <code>null</code> indicates a null value, not the string literal <code>\"null\"</code></p>"},{"location":"request_matching/#matching-an-xml-request-body","title":"Matching an XML request body","text":"<p>You can match a resource based on a XPath query of a XML request body.</p> <p>Only XML request bodies are supported for the feature.</p> <p>Specify the match configuration using the <code>requestBody.xPath</code> property of a resource.</p> <p>Here you specify a XPath expression, relevant namespaces, and the value it must match.</p> <p>For example:</p> <pre><code>resources:\n- method: GET\n  path: /example1\n  requestBody:\n    xPath: \"/env:Envelope/env:Body/pets:animal/pets:name\"\n    value: \"Fluffy\"\n    xmlNamespaces:\n      env: \"http://schemas.xmlsoap.org/soap/envelope/\"\n      pets: \"urn:com:example:petstore\"\n  response:\n    statusCode: 204\n</code></pre> <p>This example will match a request body like this:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;env:Envelope xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\n  &lt;env:Header/&gt;\n  &lt;env:Body&gt;\n    &lt;pets:animal xmlns:pets=\"urn:com:example:petstore\"&gt;\n      &lt;pets:name&gt;Fluffy&lt;/pets:name&gt;\n    &lt;/pets:animal&gt;\n  &lt;/env:Body&gt;\n&lt;/env:Envelope&gt;\n</code></pre> <p>Note: although this example uses a SOAP envelope, any valid XML body can be matched.</p>"},{"location":"request_matching/#reusing-xml-namespace-definitions","title":"Reusing XML namespace definitions","text":"<p>Instead of specifying the namespace definitions for each XPath expression, you can define them once at the top level of the configuration:</p> <pre><code>plugin: rest\n\nresources:\n- method: GET\n  path: /example1\n  requestBody:\n    xPath: \"/env:Envelope/env:Body/pets:animal/pets:name\"\n    value: \"Fluffy\"\n  response:\n    statusCode: 204\n\n- method: GET\n  path: /example2\n  requestBody:\n    xPath: \"/env:Envelope/env:Body/pets:animal/pets:name\"\n    value: \"Paws\"\n  response:\n    statusCode: 400\n\n# XML namespaces shared by all XPath expressions\nsystem:\n  xmlNamespaces:\n    env: \"http://schemas.xmlsoap.org/soap/envelope/\"\n    pets: \"urn:com:example:petstore\"\n</code></pre> <p>Any of the match operators, such as <code>Contains</code>, <code>Matches</code> etc. can be used in an XPath matcher.</p>"},{"location":"request_matching/#unmatched-or-null-xpath-expressions","title":"Unmatched or null XPath expressions","text":"<p>If the result of evaluating the XPath expression is <code>null</code> or if the path evaluates to non-existent property in the body, then it is considered <code>null</code>.</p> <p>You can explicitly match a <code>null</code> value, as follows:</p> <pre><code>resources:\n- method: GET\n  path: /example-nonmatch\n  requestBody:\n    xPath: \"/env:Envelope/env:Body/pets:animal/pets:nothing\"\n    # tilde is YAML for null\n    value: ~\n    xmlNamespaces:\n      env: \"http://schemas.xmlsoap.org/soap/envelope/\"\n      pets: \"urn:com:example:petstore\"\n  response:\n    statusCode: 409\n</code></pre> <p>Note: the YAML keyword <code>null</code> indicates a null value, not the string literal <code>\"null\"</code></p>"},{"location":"request_matching/#matching-raw-request-body-content","title":"Matching raw request body content","text":"<p>You can match a resource based on the raw content of the request body.</p> <p>Specify the match configuration using the <code>requestBody.operator</code> and <code>requestBody.value</code> properties of a resource.</p> <p>Here you specify the operator and a value to compare.</p> <p>For example:</p> <pre><code>resources:\n- method: GET\n  path: /example1\n  requestBody:\n    operator: EqualTo\n    value: bar\n  response:\n    statusCode: 204\n</code></pre> <p>This example will match a request body like this:</p> <pre><code>bar\n</code></pre> <p>Any of the match operators, such as <code>Contains</code>, <code>Matches</code> etc. can be used in a request body matcher.</p>"},{"location":"request_matching/#matching-an-empty-request-body","title":"Matching an empty request body","text":"<p>If the request body is empty, then it is considered <code>null</code>.</p> <p>You can explicitly match a <code>null</code> value, as follows:</p> <pre><code>resources:\n- method: GET\n  path: /example2\n  requestBody:\n    operator: EqualTo\n    value: null\n  response:\n    statusCode: 409\n</code></pre> <p>Note: the YAML keyword <code>null</code> indicates a null value, not the string literal <code>\"null\"</code></p>"},{"location":"request_matching/#using-multiple-request-body-matchers","title":"Using multiple request body matchers","text":"<p>You can use multiple request body matchers for a resource. Using the <code>allOf</code> or <code>anyOf</code> conditions controls how the matchers are combined.</p>"},{"location":"request_matching/#all-matchers-must-match","title":"All matchers must match","text":"<pre><code>resources:\n- method: GET\n  path: /example1\n  requestBody:\n    allOf:\n    - jsonPath: $.foo\n      value: bar\n    - jsonPath: $.baz\n      value: qux\n  response:\n    statusCode: 204\n</code></pre>"},{"location":"request_matching/#at-least-one-matcher-must-match","title":"At least one matcher must match","text":"<pre><code>resources:\n- method: GET\n  path: /example1\n  requestBody:\n    anyOf:\n    - jsonPath: $.foo\n      value: bar\n    - jsonPath: $.baz\n      value: qux\n  response:\n    statusCode: 204\n</code></pre>"},{"location":"request_matching/#body-match-operators","title":"Body match operators","text":"<p>Body matchers support the range of operators described in this document.</p> <p>For example:</p> <pre><code>resources:\n- method: GET\n  path: /example1\n  requestBody:\n    jsonPath: $.foo\n    value: bar\n    operator: NotEqualTo\n  response:\n    statusCode: 400\n</code></pre> <p>Note If no <code>operator</code> is specified, then <code>EqualTo</code> is used.</p>"},{"location":"request_matching/#matching-using-expressions","title":"Matching using expressions","text":"<p>You can match resources using expressions, using the template syntax. This provides a powerful way to match against request attributes (including headers, path parameters, query parameters, or body content) as well as store items (including the <code>request</code> store).</p>"},{"location":"request_matching/#using-allof-expressions","title":"Using allOf expressions","text":"<p>Use the <code>allOf</code> property when all expressions must evaluate to true for the resource to be matched.</p> <p>For example:</p> <pre><code>resources:\n- method: POST\n  path: /example\n  allOf:\n    - expression: \"${context.request.headers.Authorization}\"\n      operator: Matches\n      value: \"Bearer .*\"\n    - expression: \"${context.request.headers.X-API-Version}\"\n      operator: EqualTo\n      value: \"2024-01\"\n  response:\n    statusCode: 204\n</code></pre> <p>This example will match a request with both headers:</p> <pre><code>Authorization: Bearer abc123\nX-API-Version: 2024-01\n</code></pre>"},{"location":"request_matching/#using-anyof-expressions","title":"Using anyOf expressions","text":"<p>Use the <code>anyOf</code> property when at least one expression must evaluate to true for the resource to be matched.</p> <p>For example:</p> <pre><code>resources:\n- method: POST\n  path: /example\n  anyOf:\n    - expression: \"${context.request.headers.X-Legacy-Auth}\"\n      operator: EqualTo\n      value: \"legacy-token\"\n    - expression: \"${context.request.headers.Authorization}\"\n      operator: Matches\n      value: \"Bearer .*\"\n  response:\n    statusCode: 204\n</code></pre> <p>This example will match a request with either header:</p> <pre><code>X-Legacy-Auth: legacy-token\n</code></pre> <p>or:</p> <pre><code>Authorization: Bearer abc123\n</code></pre>"},{"location":"request_matching/#using-match-operators","title":"Using match operators","text":"<p>Any of the match operators, such as <code>Contains</code> and <code>Matches</code>, can be used in an expression matcher. If no operator is specified, <code>EqualTo</code> is used by default.</p> <p>For example, using the <code>Contains</code> operator:</p> <pre><code>resources:\n- method: POST\n  path: /example\n  allOf:\n    - expression: \"${context.request.headers.X-Test}\"\n      operator: Contains\n      value: \"test\"\n  response:\n    content: \"Header contains test\"\n</code></pre> <p>Or using a regular expression with the <code>Matches</code> operator:</p> <pre><code>resources:\n- method: POST\n  path: /example\n  allOf:\n    - expression: \"${context.request.headers.X-Test}\"\n      operator: Matches\n      value: \"test-.*\"\n  response:\n    content: \"Header matches pattern\"\n</code></pre>"},{"location":"request_matching/#expression-syntax","title":"Expression syntax","text":"<p>Expressions use the template syntax. See Response templates for details of the available placeholders and syntax.</p> <p>Common placeholders include:</p> <ul> <li><code>${context.request.headers.HEADER_NAME}</code> - Access request headers</li> <li><code>${context.request.pathParams.PARAM_NAME}</code> - Access path parameters</li> <li><code>${context.request.queryParams.PARAM_NAME}</code> - Access query parameters</li> <li><code>${context.request.body}</code> - Access the raw request body</li> <li><code>${context.request.path}</code> - Access the request path</li> <li><code>${context.request.uri}</code> - Access the full request URI</li> <li><code>${stores.request.someKey}</code> - Access a value stored in the <code>request</code> store</li> <li><code>${stores.example.someKey}</code> - Access a value stored in the <code>example</code> store</li> </ul>"},{"location":"request_matching/#directory-based-responses","title":"Directory-based responses","text":"<p>See Directory-based responses for a way to serve files from a directory based on the incoming request path.</p>"},{"location":"request_matching/#resource-matching-performance","title":"Resource matching performance","text":"<p>Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath or XPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance.</p>"},{"location":"rest_plugin/","title":"REST plugin","text":"<ul> <li>Plugin name: <code>rest</code></li> <li>Plugin class: <code>io.gatehill.imposter.plugin.rest.RestPluginImpl</code></li> </ul>"},{"location":"rest_plugin/#features","title":"Features","text":"<ul> <li>Supports RESTful or plain HTTP APIs.</li> <li>Supports arbitrary format static files.</li> <li>Supports optional JSON array responses.</li> </ul>"},{"location":"rest_plugin/#configuration","title":"Configuration","text":"<p>Read the Configuration section to understand how to configure Imposter.</p>"},{"location":"rest_plugin/#additional-context-objects","title":"Additional context objects","text":"<p>None.</p>"},{"location":"rest_plugin/#example","title":"Example","text":"<p>Here is an example configuration file:</p> <pre><code># simple-example-config.yaml\n---\nplugin: rest\npath: \"/example\"\nresponse:\n  file: example-data.json\n</code></pre> <p>In this example, we are using a static response file (<code>example-data.json</code>) containing the following:</p> <pre><code>{\n  \"hello\": \"world\"\n}\n</code></pre>"},{"location":"rest_plugin/#start-imposter-with-the-rest-plugin","title":"Start Imposter with the REST plugin","text":"<p>The REST plugin is bundled with the core Imposter distribution.</p> <p>Let's assume your configuration is in the directory: <code>examples/rest/simple</code>.</p> <p>CLI example:</p> <pre><code>imposter up ./examples/rest/simple\n</code></pre> <p>Docker example:</p> <pre><code>docker run --rm -ti -p 8080:8080 \\\n    -v $PWD/examples/rest/simple:/opt/imposter/config \\\n    outofcoffee/imposter\n</code></pre> <p>Standalone Java example:</p> <pre><code>java -jar distro/core/build/libs/imposter-core.jar \\\n    --configDir ./examples/rest/simple\n</code></pre> <p>Send an HTTP request to the <code>/example</code> path defined in the configuration file to see the example response:</p> <pre><code>$ curl -v http://localhost:8080/example\n...\nHTTP/1.1 200 OK\n...\n{\n  \"hello\": \"world\"\n}\n</code></pre> <p>Once you're finished, stop the server with CTRL+C.</p>"},{"location":"rest_plugin/#multiple-paths","title":"Multiple paths","text":"<p>We can configure different responses at multiple paths as follows:</p> <pre><code># multi-response-config.yaml\n---\nplugin: rest\ncontentType: application/json\nresources:\n  - path: \"/cats/{id}\"\n    type: array\n    response:\n      file: cats.json\n  - path: \"/dogs/{id}\"\n    type: array\n    response:\n      file: dogs.json\n</code></pre> <p>Some highlights:</p> <ul> <li>We\u2019ve defined the endpoint <code>/cats</code> to return the contents of our sample JSON file; in other words an array of cats.</li> <li>We\u2019ve also said that, because the response file is a JSON array, we want to allow querying of individual items by their ID, under the <code>/cats/{id}</code> endpoint.</li> <li>This example assumes you\u2019ve named the file containing your JSON array <code>cats.json</code> and that it is in the same directory as the configuration file.</li> </ul> <p>Let's return an array of data at each endpoint:</p> <pre><code># cats.json\n[\n  {\n    \"id\": 1,\n    \"name\": \"Fluffy\",\n    \"type\": \"Persian\"\n  },\n  {\n    \"id\": 2,\n    \"name\": \"Leo\",\n    \"type\": \"Bengal\"\n  }\n]\n\n# dogs.json\n[\n  {\n    \"id\": 1,\n    \"name\": \"Rex\",\n    \"type\": \"Labrador\"\n  },\n  {\n    \"id\": 2,\n    \"name\": \"Fido\",\n    \"type\": \"Husky\"\n  }\n]\n</code></pre> <p>Start the server:</p> <pre><code>docker run --rm -ti -p 8080:8080 \\\n    -v $PWD/examples/rest/multiple:/opt/imposter/config \\\n    outofcoffee/imposter\n</code></pre> <p>Send an HTTP request to the <code>/cats/1</code> path defined in the configuration file to see the first item in the array:</p> <pre><code>$ curl -v http://localhost:8080/cats/1\n...\nHTTP/1.1 200 OK\n...\n{\n  \"id\": 1,\n  \"name\": \"Fluffy\",\n  \"type\": \"Persian\"\n}\n</code></pre> <p>Once you're finished, stop the server with CTRL+C.</p> <p>For more working examples, see:</p> <ul> <li>examples/rest</li> <li>mock/rest/src/test/resources/config</li> </ul>"},{"location":"rest_plugin/#scripted-responses-advanced","title":"Scripted responses (advanced)","text":"<p>For simple scenarios, use the <code>file</code> property within the <code>response</code> object in your configuration.</p> <p>For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts.</p> <p>See the Scripting section for more information.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>This section lists future ideas for features and improvements. Feel free to submit a suggestion by raising an issue.</p>"},{"location":"roadmap/#features","title":"Features","text":"<ul> <li>Non-HTTP transports</li> <li>Asynchronous requests (i.e. callbacks)</li> <li>Asynchronous responses</li> <li>Scheduled HTTP(S) invocations</li> <li>Scheduled script executions</li> <li>Request and response validation against a JSON Schema file (instead of just OpenAPI spec)</li> <li>SOAP plugin - validate request/response body against XSD.</li> <li>Autogenerate OpenAPI spec/UI for REST plugin.</li> </ul>"},{"location":"roadmap/#improvements","title":"Improvements","text":""},{"location":"roadmap/#capture","title":"Capture","text":"<ul> <li>Replace <code>const</code> and <code>expression</code> with <code>value</code> key in capture block.</li> </ul>"},{"location":"roadmap/#hbase","title":"HBase","text":"<ul> <li>Add content type header to HBase response</li> <li>Reuse HBase model classes for JSON serialisation</li> </ul>"},{"location":"roadmap/#breaking-changes","title":"Breaking changes","text":"<p>The following items are breaking changes, such as removal of deprecated functionality. They will be removed or changed in a backwards incompatible way in a future major version.</p> <ul> <li>Remove deprecated <code>withData(String?)</code> script function</li> <li>Request and response validation will be enabled by default</li> <li>Remove deprecated <code>IMPOSTER_S3_CONFIG_URL</code> environment variable</li> </ul>"},{"location":"run_imposter_aws_lambda/","title":"Running Imposter in AWS Lambda","text":"<p>There are many ways to run Imposter. This section describes how to run it as a Lambda function in AWS.</p> Other ways to run Imposter <p>Standalone mock server</p> <ul> <li>Using the command line client - see Imposter CLI</li> <li>As a Docker container - see Imposter Docker container</li> <li>As a JAR file on the JVM - see Imposter JAR file</li> </ul> <p>Embedded in tests</p> <ul> <li>Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings</li> <li>Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings</li> </ul> <p>Within your CI/CD pipeline</p> <ul> <li>Use the Imposter GitHub Actions to start and stop Imposter during your CI/CD pipeline.</li> </ul>"},{"location":"run_imposter_aws_lambda/#aws-lambda-features","title":"AWS Lambda Features","text":"<ul> <li>Access to mock server via Lambda function URL (or AWS API Gateway)</li> <li>Supports OpenAPI, REST and SOAP mocks</li> <li>Supports Stores for recording data for later use or review</li> </ul>"},{"location":"run_imposter_aws_lambda/#deployment-options","title":"Deployment options","text":"<p>You can deploy Imposter as a Lambda function in various ways, such as the AWS Console, using infrastructure as code (e.g. Terraform) or a framework such as Serverless.</p> <p>Another option is to use the Imposter CLI, which has some opinionated choices to make things easier. You should choose the option that best suits your environment.</p>"},{"location":"run_imposter_aws_lambda/#deploy-to-lambda-using-imposter-cli","title":"Deploy to Lambda using Imposter CLI","text":"<p>You can deploy as a Lambda function using the Imposter CLI.</p>"},{"location":"run_imposter_aws_lambda/#deploy-to-lambda-using-imposter-cli_1","title":"\ud83d\udcd6 Deploy to Lambda using Imposter CLI","text":""},{"location":"run_imposter_aws_lambda/#deploy-to-lambda-using-aws-console","title":"Deploy to Lambda using AWS Console","text":"<p>You can also deploy as a Lambda function using the AWS Console.</p>"},{"location":"run_imposter_aws_lambda/#deploy-to-lambda-using-aws-console_1","title":"\ud83d\udcd6 Deploy to Lambda using AWS Console","text":""},{"location":"run_imposter_aws_lambda/#deploy-to-lambda-with-serverless-framework","title":"Deploy to Lambda with Serverless Framework","text":"<p>You can also deploy as a Lambda function using Serverless Framework.</p>"},{"location":"run_imposter_aws_lambda/#deploy-to-lambda-with-serverless-framework_1","title":"\ud83d\udcd6 Deploy to Lambda with Serverless Framework.","text":""},{"location":"run_imposter_aws_lambda/#other-ways-to-deploy-to-lambda","title":"Other ways to deploy to Lambda","text":"<p>You can also deploy using infrastructure as code tools (e.g. Terraform or CloudFormation).</p>"},{"location":"run_imposter_aws_lambda/#whats-next","title":"What's next","text":"<ul> <li>Learn how to use Imposter with the Configuration guide.</li> </ul>"},{"location":"run_imposter_cli/","title":"Running Imposter with the CLI","text":"<p>There are many ways to run Imposter. This section describes using the command line interface (CLI) tool.</p> Other ways to run Imposter <p>Standalone mock server</p> <ul> <li>As a Lambda function in AWS - see Imposter AWS Lambda</li> <li>As a Docker container - see Imposter Docker container</li> <li>As a JAR file on the JVM - see Imposter JAR file</li> </ul> <p>Embedded in tests</p> <ul> <li>Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings</li> <li>Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings</li> </ul> <p>Within your CI/CD pipeline</p> <ul> <li>Use the Imposter GitHub Actions to start and stop Imposter during your CI/CD pipeline.</li> </ul>"},{"location":"run_imposter_cli/#cli-features","title":"CLI Features","text":"<ul> <li>Start mocks (<code>imposter up</code>)</li> <li>Generate mock configuration from OpenAPI files (<code>imposter scaffold</code>)</li> <li>Supports all plugins</li> <li>Supports JVM and Docker engine types</li> <li>Supports both 'core' and 'all' distributions</li> </ul>"},{"location":"run_imposter_cli/#installation","title":"Installation","text":""},{"location":"run_imposter_cli/#prerequisites","title":"Prerequisites","text":"<p>You must have Docker or a JVM installed.</p>"},{"location":"run_imposter_cli/#homebrew","title":"Homebrew","text":"<p>If you have Homebrew installed:</p> <pre><code>brew tap gatehill/imposter\nbrew install imposter\n</code></pre>"},{"location":"run_imposter_cli/#shell-script","title":"Shell script","text":"<p>Or, use this one liner (macOS and Linux only):</p> <pre><code>curl -L https://raw.githubusercontent.com/imposter-project/imposter-cli/main/install/install_imposter.sh | bash -\n</code></pre>"},{"location":"run_imposter_cli/#other-installation-options","title":"Other installation options","text":"<p>See the full Installation instructions for your system.</p>"},{"location":"run_imposter_cli/#example","title":"Example","text":"<pre><code>$ cd /path/to/config\n$ imposter up\n\nStarting server on port 8080...\nParsing configuration file: someapi-config.yaml\n...\nMock server is up and running\n</code></pre>"},{"location":"run_imposter_cli/#different-distributions","title":"Different distributions","text":"<p>The previous command starts Imposter using the 'core' distribution, which includes common plugins only. To use the 'all' distribution, which includes all plugins, use the <code>-t</code> (engine type) flag:</p> <pre><code>$ imposter up -t docker-all\n</code></pre>"},{"location":"run_imposter_cli/#cli-usage","title":"CLI usage","text":"<p>See full usage instructions on Imposter CLI.</p>"},{"location":"run_imposter_cli/#whats-next","title":"What's next","text":"<ul> <li>Learn how to use Imposter with the Configuration guide.</li> </ul>"},{"location":"run_imposter_docker/","title":"Running Imposter as a Docker container","text":"<p>There are many ways to run Imposter. This section describes how to use the Docker container.</p> Other ways to run Imposter <p>Standalone mock server</p> <ul> <li>Using the command line client - see Imposter CLI</li> <li>As a Lambda function in AWS - see Imposter AWS Lambda</li> <li>As a JAR file on the JVM - see Imposter JAR file</li> </ul> <p>Embed in unit/integration tests</p> <ul> <li>Embed within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings</li> <li>Embed within your JavaScript/Node.js unit tests - see JavaScript bindings</li> </ul> <p>Within your CI/CD pipeline</p> <ul> <li>Use the Imposter GitHub Actions to start and stop Imposter during your CI/CD pipeline.</li> </ul>"},{"location":"run_imposter_docker/#docker-image-features","title":"Docker Image Features","text":"<ul> <li>Start mocks</li> <li>Supports all plugins</li> </ul>"},{"location":"run_imposter_docker/#prerequisites","title":"Prerequisites","text":"<p>You must have Docker installed.</p> <p>The easiest way to get started is to use an Imposter Docker container, such as:</p> <pre><code>docker run -ti -p 8080:8080 outofcoffee/imposter [args]\n</code></pre>"},{"location":"run_imposter_docker/#docker-images","title":"Docker images","text":"<p>Most users should choose the 'core' image available at: outofcoffee/imposter. This is the primary Imposter Docker image supporting both OpenAPI plain REST APIs and SOAP web services.</p> <p>The following images are available:</p> Image Docker Hub link Plugins Notes core outofcoffee/imposter openapi, rest, soap This is the primary Imposter Docker image supporting OpenAPI, plain REST APIs and SOAP/WSDL mocks. Most users should choose this. all outofcoffee/imposter-all All plugins Contains all mock plugins. Largest image, with the most dependencies. distroless outofcoffee/imposter-distroless Same as <code>core</code> image. Built on the <code>distroless</code> base image. Smallest image, with the fewest dependencies. <p>You can also use the these images to create your own custom images with embedded configuration.</p>"},{"location":"run_imposter_docker/#configuration-location","title":"Configuration location","text":"<p>When running the Imposter Docker container, place your files at the path within the container:</p> <pre><code>/opt/imposter/config\n</code></pre> <p>This is the location that the mock engine looks for configuration files (i.e. those with the <code>-config.yaml</code> suffix). Any files referenced from your configuration files will be resolved relative to this path within the container.</p>"},{"location":"run_imposter_docker/#run-container","title":"Run container","text":"<p>To run Imposter, map the path to the configuration files directory to the <code>/opt/imposter/config</code> directory within the container.</p> <pre><code>docker run -ti -v /path/to/config:/opt/imposter/config -p 8080:8080 outofcoffee/imposter\n</code></pre> <p>To get up and running quickly, see the examples.</p>"},{"location":"run_imposter_docker/#example","title":"Example","text":"<pre><code>$ docker run -it -p 8080:8080 -v $PWD/example-api:/opt/imposter/config outofcoffee/imposter\n\nStarting mock engine 2.13.1\nLoading configuration file: /opt/imposter/config/someapi-config.yaml\n...\nMock engine up and running on http://localhost:8080\n</code></pre> <p>The mock server is running at http://localhost:8080</p>"},{"location":"run_imposter_docker/#build-a-self-contained-image","title":"Build a self-contained image","text":"<p>You can also build a self-contained image, containing both the Imposter mock engine and your configuration files. This makes your mock portable to wherever Docker runs.</p> <p>Let's assume the following file structure:</p> <pre><code>.\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 config\n    \u251c\u2500\u2500 petstore-config.yaml\n    \u2514\u2500\u2500 petstore.yaml\n</code></pre> <p>The content of the <code>Dockerfile</code> would be as follows:</p> <pre><code>FROM outofcoffee/imposter\nCOPY ./config/* /opt/imposter/config/\n</code></pre> <p>Build your container image as follows:</p> <pre><code>$ docker build -t imposter-example .\n\nSending build context to Docker daemon   5.12kB\nStep 1/2 : FROM outofcoffee/imposter\n ---&gt; 36d19405d09b\nStep 2/2 : COPY ./config/* /opt/imposter/config/\n ---&gt; 1f2667a1d5e5\nSuccessfully built 1f2667a1d5e5\nSuccessfully tagged imposter-example:latest\n</code></pre> <p>The container image <code>imposter-example</code> contains both the Imposter mock engine and your configuration files from the <code>config</code> directory.</p> <p>Run the container:</p> <pre><code>$ docker run -it -p 8080:8080 imposter-example\n\nStarting mock engine 2.13.1\nLoading configuration file: /opt/imposter/config/petstore-config.yaml\n...\nMock engine up and running on http://localhost:8080\n</code></pre> <p>The mock server is running at http://localhost:8080</p>"},{"location":"run_imposter_docker/#custom-docker-images","title":"Custom Docker images","text":"<p>The default container images are stripped back and do not have any binaries under <code>/usr/bin</code>. This is to reduce their size and attack surface.</p> <p>One consequence is that shell commands in custom Dockerfiles don't work with the default Docker images when simply extending <code>FROM</code> them as the base image.</p> <p>However, it is possible to build container images and use shell commands in a Dockerfile, if you build a container image using multi-stage builds.</p> <p>An example</p> <p>Here is an example of a custom Docker image: https://github.com/imposter-project/examples/blob/main/docker/Dockerfile</p> <p>This example extends from the Java base image so has its various userspace tools available (and more you can install with the package manager).</p>"},{"location":"run_imposter_docker/#whats-next","title":"What's next","text":"<ul> <li>Learn how to use Imposter with the Configuration guide.</li> <li>See full usage instructions.</li> </ul>"},{"location":"run_imposter_jar/","title":"Running Imposter as a JAR on the JVM","text":"<p>There are many ways to run Imposter. This section describes how to use a JAR file on the JVM.</p> Other ways to run Imposter <p>Standalone mock server</p> <ul> <li>Using the command line client - see Imposter CLI</li> <li>As a Docker container - see Imposter Docker container</li> <li>As a Lambda function in AWS - see Imposter AWS Lambda</li> </ul> <p>Embed in unit/integration tests</p> <ul> <li>Embed within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings</li> <li>Embed within your JavaScript/Node.js unit tests - see JavaScript bindings</li> </ul> <p>Within your CI/CD pipeline</p> <ul> <li>Use the Imposter GitHub Actions to start and stop Imposter during your CI/CD pipeline.</li> </ul>"},{"location":"run_imposter_jar/#jar-file-features","title":"JAR File Features","text":"<ul> <li>Start mocks</li> <li>Supports all plugins</li> </ul> <p>Note: if you want to embed Imposter in your JUnit tests, see JVM bindings instead.</p>"},{"location":"run_imposter_jar/#run","title":"Run","text":""},{"location":"run_imposter_jar/#prerequisites","title":"Prerequisites","text":"<p>You must have a JVM installed. Java 11 and 15 have been confirmed as compatible. Others may also be, but are not currently tested.</p> <p>Note: As of version 3, Imposter no longer supports Java 8. If Java 8 support is required, Imposter 2.x is still available, but may no longer be maintained.</p> <p>Run the JAR as follows:</p> <pre><code>java -jar distro/all/build/libs/imposter-all.jar \\\n    --plugin &lt;plugin name&gt; \\\n    --configDir &lt;config dir&gt; \\\n    [args]\n</code></pre> <p>...ensuring that you choose the right plugin you wish to use, for example:</p> <pre><code>java -jar distro/all/build/libs/imposter-all.jar \\\n    --plugin rest \\\n    --configDir /path/to/config \\\n    [args]\n</code></pre>"},{"location":"run_imposter_jar/#example","title":"Example","text":"<pre><code>$ java -jar ./imposter-all.jar --plugin rest --configDir ./example-api\n\nStarting server on port 8080...\nParsing configuration file: someapi-config.yaml\n...\nMock server is up and running\n</code></pre>"},{"location":"run_imposter_jar/#usage","title":"Usage","text":"<p>See full usage instructions.</p>"},{"location":"run_imposter_jar/#whats-next","title":"What's next","text":"<ul> <li>Learn how to use Imposter with the Configuration guide.</li> </ul>"},{"location":"scaffold/","title":"Generate configuration using scaffold","text":"<p>You can get Imposter to create configuration files for you.</p> <p>If you have an existing endpoint from which to record requests and responses, see the proxy documentation</p> <p>If you have an OpenAPI specification, Imposter can 'scaffold' a mock based on the resources and methods, it contains.</p> <p>If you don't have either of these, it's easy to create the configuration using the guide.</p>"},{"location":"scaffold/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install the Imposter CLI</li> </ul>"},{"location":"scaffold/#scaffolding-from-an-openapi-specification","title":"Scaffolding from an OpenAPI specification","text":"<p>Let's start with a simple OpenAPI file:</p> <pre><code># petstore.yaml\n---\nopenapi: \"3.0.1\"\n\ninfo:\n  title: Sample Petstore service\n  version: \"1.0.0\"\n\npaths:\n  /pets:\n    get:\n      responses:\n        '200':\n          description: Returns all pets from the system\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  required:\n                    - id\n                    - name\n                  properties:\n                    id:\n                      type: integer\n                    name:\n                      type: string\n              examples:\n                itemsExample:\n                  value:\n                    [\n                      { \"id\": 101, \"name\": \"Cat\" },\n                      { \"id\": 102, \"name\": \"Dog\" }\n                    ]\n</code></pre> <p>Store this as a file named <code>petstore.yaml</code>.</p> <p>Imposter can generate a configuration file from this specification:</p> <pre><code>$ imposter scaffold\n\nfound 1 OpenAPI spec(s)\ngenerated 1 resources from spec\nwrote Imposter config: /Users/mary/example/petstore-config.yaml\n</code></pre> <p>Look in the directory where you started Imposter and you will see a new file:</p> <pre><code>$ ls -l\n-rw-r--r--  1 mary  wheel    79B  8 Sep 15:44 petstore-config.yaml\n-rw-r--r--  1 mary  wheel   800B  8 Sep 15:44 petstore.yaml\n</code></pre> <p>The <code>petstore-config.yaml</code> file is the Imposter configuration file:</p> <pre><code># petstore-config.yaml\n---\nplugin: openapi\nspecFile: petstore.yaml\n\nresources:\n  - method: GET\n    path: /pets\n</code></pre> <p>Note that the HTTP method and path from the specification have been picked up. Since the <code>openapi</code> plugin is being used, when a request is made to this resource, the <code>examples</code> from the OpenAPI specification will be used.</p>"},{"location":"scaffold/#testing-the-mock","title":"Testing the mock","text":"<p>In the same directory as the files above, start Imposter:</p> <pre><code>$ imposter up\n\nStarting mock engine 3.0.4\nLoading configuration file: /opt/imposter/config/petstore-config.yaml\nAdding mock endpoint: GET -&gt; /pets\nAdding specification UI at: http://localhost:8080/_spec\nMock engine up and running on http://localhost:8080\n</code></pre> <p>Imposter read the configuration files and a mock of the API is now running at <code>http://localhost:8080</code></p> <p>Call the mock:</p> <pre><code>$ curl http://localhost:8080/pets\n\n[{\"id\":101,\"name\":\"Cat\"},{\"id\":102,\"name\":\"Dog\"}]\n</code></pre> <p>Imposter served the response based on what it captured.</p> <pre><code>Matched resource config for GET http://localhost:8080/pets\nSetting content type [application/json] from specification for GET http://localhost:8080/pets\nServing mock example for GET http://localhost:8080/pets with status code 200 (response body 49 bytes)\n</code></pre>"},{"location":"scaffold/#making-changes","title":"Making changes","text":"<p>You can, of course, edit the configuration file so the mock behaves differently. When you change either the configuration file or response file, the Imposter CLI will restart to reflect your latest changes.</p>"},{"location":"scaffold/#whats-next","title":"What's next","text":"<p>Learn how to use Imposter with the Configuration guide.</p>"},{"location":"scripting/","title":"Scripted responses","text":"<p>Read this section to learn how to use scripts to configure Imposter's responses.</p> <p>You can control Imposter's responses using JavaScript or Groovy scripts. (If you choose Groovy, you can of course write plain Java in your scripts as well).</p>"},{"location":"scripting/#example","title":"Example","text":"<p>Here's an example configuration file that uses a script:</p> <pre><code># scripted-example-config.yaml\n---\nplugin: rest\npath: \"/example-two\"\nresponse:\n  scriptFile: example.groovy\n</code></pre> <p>...and here's the corresponding script (<code>example.groovy</code>):</p> <pre><code>if (context.request.queryParams.action == 'create') {\n    respond().withStatusCode(201)\n}\n</code></pre> <p>We will explain this syntax later, in the ResponseBehaviour object section. For now, it's enough to know that the example above causes the mock server to respond with HTTP status code 201 if the value of the <code>action</code> parameter in the request is <code>create</code>.</p> <p>For example:</p> <pre><code>HTTP GET http://localhost:8080/example-two?action=create\n...\n201 Created\n</code></pre> <p>Note See this rest plugin example for a simple example.</p>"},{"location":"scripting/#another-example","title":"Another example","text":"<p>Here's a more sophisticated example script:</p> <pre><code>switch (context.request.queryParams.action) {\n    case 'create':\n        // HTTP Status-Code 201: Created.\n        respond()\n            .withStatusCode(201)\n            .skipDefaultBehaviour()\n        break\n\n    case 'fetch':\n        // use a static response file and the default plugin behaviour\n        respond().withFile('example-data.json')\n        break\n\n    default:\n        // default to bad request\n        respond()\n            .withStatusCode(400)\n            .skipDefaultBehaviour()\n        break\n}\n</code></pre> <p>In this example, the script causes the mock server to respond with HTTP status codes 200, 201 or 400 depending on the value of the <code>action</code> parameter in the request.</p> <p>For example:</p> <pre><code>HTTP GET http://localhost:8080/example-two?action=fetch\n...\nHTTP/1.1 200 OK\n...\n{\n  \"hello\": \"world\"\n}\n</code></pre> <p>In the case of <code>action=fetch</code>, the script causes the mock server to use the content of the static file <code>static-data.json</code> to serve the response.</p> <p>And:</p> <pre><code>HTTP GET http://localhost:8080/example-two?action=foo\n...\n400 Bad Request\n</code></pre> <p>In the default case, the script causes the mock server to return an HTTP 400 response, as shown above.</p> <p>The <code>queryParams</code> object used in the script is just a map of the request query parameters, so you can use either <code>params.yourParamName</code> or <code>params['yourParamName']</code> syntax to access its members.</p> <p>There are many other script objects you could use in order to decide what to return. For example, your script might use the request method (GET, POST, PUT, DELETE etc.) or other request attributes.</p>"},{"location":"scripting/#script-objects","title":"Script objects","text":"<p>The following objects are available to your scripts, to help you determine what action to take.</p> Object Description <code>context</code> Parent object for accessing request properties <code>config</code> The plugin configuration for the current request <code>env</code> A map of environment variables, such as <code>{ \"MY_VAR\": \"abc\", \"VAR2\": \"def\" }</code> <code>logger</code> Logger, supporting levels such as <code>info(String)</code>, <code>warn(String)</code> etc. <p>For example, if you want to access the directory containing the configuration file, you can use <code>config.dir</code>.</p> JavaScript example <pre><code>console.log(\"Path to config dir: \" + config.dir)\n\nvar someFile = config.dir + \"/example.txt\"\n// use someFile...\n</code></pre> Groovy example <pre><code>logger.info(\"Path to config dir: \" + config.dir)\n\ndef someFile = new java.io.File(config.dir, \"example.txt\")\n// use someFile...\n</code></pre>"},{"location":"scripting/#context-object","title":"Context object","text":"<p>The <code>context</code> object is available to your scripts. It holds things you might like to interrogate, like the request object.</p> Property Description Example <code>request</code> The HTTP request. See Request object. <p>Note: Certain plugins will add additional properties to the <code>context</code>. For example, the hbase plugin provides a <code>tableName</code> object, which you can use to determine the HBase table for the request being served.</p>"},{"location":"scripting/#request-object","title":"Request object","text":"<p>The request object is available on the <code>context</code>. It provides access to request parameters, method, URI etc.</p> Property Description Example <code>path</code> The path of the request. <code>\"/example\"</code> <code>method</code> The HTTP method of the request. <code>\"GET\"</code> <code>pathParams</code> A map containing the request path parameters. <code>{ \"productCode\": \"abc\", \"foo\": \"bar\" }</code> <code>queryParams</code> A map containing the request query parameters. <code>{ \"limit\": \"10\", \"foo\": \"bar\" }</code> <code>formParams</code> A map containing the request form parameters. <code>{ \"foo\": \"bar\" }</code> <code>uri</code> The absolute URI of the request. <code>\"http://example.com?foo=bar&amp;baz=qux\"</code> <code>headers</code> A map containing the request headers. <code>{ \"X-Example\": \"ABC123\", \"Content-Type\": \"text/plain\" }</code> <code>normalisedHeaders</code> A map containing the request headers with all keys in lowercase. <code>{ \"x-example\": \"ABC123\", \"content-type\": \"text/plain\" }</code> <code>body</code> A string containing the request body. <code>\"Hello world.\"</code> <p>Note: keys are always lowercase in <code>normalisedHeaders</code>, regardless of the request header casing. This aids script portability, avoiding case-sensitivity for header keys.</p>"},{"location":"scripting/#response-object","title":"Response object","text":"<p>Your scripts have access to the methods on <code>io.gatehill.imposter.script.MutableResponseBehaviour</code>.</p> <p>The response behaviour object provides a number of methods to enable you to control the response:</p> Method Plugin(s) Description <code>withStatusCode(int)</code> all Set the HTTP status code for the response. <code>withFile(String)</code> all Respond with the content of a static file. Also see <code>template</code>. <code>withContent(String)</code> all Respond with the literal content of a string. Also see <code>template</code>. <code>withExampleName(String)</code> openapi Use with the OpenAPI plugin to respond with a particular OpenAPI specification example. <code>withHeader(String, String)</code> all Set a response header. <code>withEmpty()</code> all Respond with empty content, or no records. <code>usingDefaultBehaviour()</code> all Use the plugin's default behaviour to respond. <code>skipDefaultBehaviour()</code> all Skip the plugin's default behaviour when responding. <code>template()</code> all Treat the response file or data as a template with placeholders. <code>continueToNext()</code> openapi, rest Used by interceptors to indicate request processing should continue after the script executes. <code>and()</code> all Syntactic sugar to improve readability of <code>respond</code> statements. <p>You structure your response behaviours like so:</p> <pre><code>respond() // ... behaviours go here\n</code></pre> <p>For example:</p> <pre><code>respond().withFile('static-data.json')\n</code></pre> <p>Or:</p> <pre><code>respond()\n    .withStatusCode(201)\n    .withHeader(\"x-custom-header\", \"somevalue\")\n</code></pre>"},{"location":"scripting/#returning-data-from-a-script","title":"Returning data from a script","text":"<p>To return data when using a script, you specify a response file or set the content to a string value.</p> <p>When using a response file, you can either:</p> <ol> <li>explicitly call the <code>withFile(String)</code> method in your script, or</li> <li>set the <code>file</code> property within the <code>response</code> object in your configuration file, which will be used by default unless you override it.</li> </ol> <p>Here's an example of setting the file from a script:</p> <pre><code>respond().withFile('some-data.json')\n</code></pre> <p>Here's an example using the <code>file</code> property within the configuration file:</p> <pre><code># example-config.yaml\n---\nplugin: rest\npath: \"/scripted\"\ncontentType: application/json\nresponse:\n  scriptFile: example.groovy\n  file: example-data.json\n</code></pre> <p>In this example, the response file <code>example-data.json</code> will be used, unless the script invokes the <code>withFile(String)</code> method with a different filename.</p>"},{"location":"scripting/#response-templates","title":"Response templates","text":"<p>Response files can be templated, allowing you to populate placeholders with dynamic data.</p>"},{"location":"scripting/#returning-raw-response-data","title":"Returning raw response data","text":"<p>You can return response data using the <code>withContent(String)</code> method.</p> <pre><code>respond().withContent('{ \"someKey\": \"someValue\" }')\n</code></pre> <p>Raw response content can also be templated, allowing you to populate placeholders with dynamic data.</p>"},{"location":"scripting/#setting-response-headers","title":"Setting response headers","text":"<p>You can set response headers using the <code>withHeader(String, String)</code> method. </p> <pre><code>respond().withHeader('X-Custom-Header', 'example value')\n</code></pre>"},{"location":"scripting/#returning-a-specific-openapi-example","title":"Returning a specific OpenAPI example","text":"<p>When using the OpenAPI plugin, you can return a specific named example from the specification using the <code>withExampleName(String)</code> method.</p> <pre><code>respond().withExampleName('example1')\n</code></pre> <p>This selects the example from the OpenAPI <code>examples</code> section for the API response.</p> <p>Note See this openapi plugin example for a simple example.</p>"},{"location":"scripting/#using-stores","title":"Using stores","text":"<p>You can read and write data in Stores using scripts.</p>"},{"location":"scripting/#overriding-plugin-behaviour","title":"Overriding plugin behaviour","text":"<p>In advanced scenarios you can control the response processing behaviour of the mock plugin you're using. </p> Skipping plugin default behaviour <p>In order for the mock server to return the response file in an appropriate format, the plugin must be allowed to process it. This is the default behaviour after your script runs.</p> <p>If you want to override the plugin's behaviour, you can call <code>skipDefaultBehaviour()</code> on the response (e.g. if you want to send an error code back).</p> <pre><code>respond()\n    .withStatusCode(400)\n    .skipDefaultBehaviour()\n</code></pre> <p>The alternative to skipping the default behaviour is <code>usingDefaultBehaviour()</code>. Whilst not required, your script can invoke this for readability to indicate that you want the plugin to handle the response file for you.</p> <p>The following blocks are semantically identical:</p> <pre><code>respond()\n    .withFile('static-data.json')\n    .usingDefaultBehaviour()\n</code></pre> <p>and:</p> <pre><code>respond().withFile('static-data.json')\n</code></pre>"},{"location":"scripting/#further-reading","title":"Further reading","text":"<ul> <li>Tips and tricks for JavaScript scripts</li> <li>Tips and tricks for Groovy scripts</li> <li>Debugging Groovy scripts</li> <li>Using modern JavaScript in scripts</li> </ul>"},{"location":"scripting_legacy_js/","title":"Using legacy JavaScript engine (Nashorn)","text":"<p>The default JavaScript engine is GraalVM, which is based on ECMAScript 2022 (more formally, ECMA-262, 13th edition). Whilst GraalVM provides support for modern JavaScript features, it is more resource intensive than the legacy Nashorn JavaScript engine, which only supports ECMAScript 5 (ES5). You can switch to the Nashorn JavaScript engine using its plugin.</p> <p>To use the Nashorn JavaScript engine, you need to be running Imposter v4.0.0 or later, and install the <code>js-nashorn</code> plugin.</p>"},{"location":"scripting_legacy_js/#install-plugin","title":"Install plugin","text":""},{"location":"scripting_legacy_js/#option-1-using-the-cli","title":"Option 1: Using the CLI","text":"<p>Note This option requires the Imposter CLI version 0.37.0 or later.</p> <p>To use this plugin, install it with the Imposter CLI:</p> <pre><code>imposter plugin install -d js-nashorn\n</code></pre> <p>This will install the plugin version matching the current engine version used by the CLI. The next time you run <code>imposter up</code>, the plugin will be available.</p>"},{"location":"scripting_legacy_js/#option-2-install-the-plugin-manually","title":"Option 2: Install the plugin manually","text":"<p>To use this plugin, download the <code>imposter-plugin-js-nashorn.jar</code> JAR file from the Releases page.</p> <p>Enable it with the following environment variable:</p> <pre><code>IMPOSTER_PLUGIN_DIR=\"/path/to/dir/containing/plugin\"\n</code></pre>"},{"location":"scripting_legacy_js/#using-the-plugin","title":"Using the plugin","text":"<p>To use Nashorn, you need to specify the <code>js-nashorn</code> engine as the JavaScript plugin. You can do this by setting the environment variable <code>IMPOSTER_JS_PLUGIN</code> to <code>js-nashorn</code>:</p> <pre><code>export IMPOSTER_JS_PLUGIN=js-nashorn\n</code></pre>"},{"location":"scripting_legacy_js/#example","title":"Example","text":"<p>Note Complete the prerequisites first.</p> <p>Start the mock server with the <code>js-nashorn</code> engine:</p> <pre><code>imposter up examples/rest/conditional-scripted -e IMPOSTER_JS_PLUGIN=js-nashorn\n</code></pre> <p>Send a request to the mock server:</p> <pre><code>curl -i http://localhost:8080/pets\n\n[\n  {\n    \"id\": 1,\n    \"name\": \"Fluffy\"\n  },\n  {\n    \"id\": 2,\n    \"name\": \"Paws\"\n  }\n]\n</code></pre> <ul> <li>See the <code>examples/rest/conditional-scripted</code> directory in GitHub.</li> </ul>"},{"location":"scripting_modern_js/","title":"Using modern JavaScript features in scripts","text":"<p>The default JavaScript engine is GraalVM, which is based on ECMAScript 2022 (more formally, ECMA-262, 13th edition). This means you can use modern JavaScript features from ECMAScript 2022 in your scripts.</p>"},{"location":"scripting_modern_js/#features","title":"Features","text":"<p>GraalVM enables you to use modern JavaScript features such as:</p> <ul> <li><code>let</code> and <code>const</code> for variable declarations</li> <li>Arrow functions</li> <li>Template literals</li> <li>Destructuring</li> <li>Classes</li> </ul> <p>To use the GraalVM JavaScript engine, you need to be running Imposter v4.0.0 or later.</p>"},{"location":"scripting_modern_js/#examples","title":"Examples","text":"<p>For examples, see the <code>examples/graal</code> directory in GitHub.</p>"},{"location":"scripting_modern_js/#simple-example","title":"Simple example","text":"<p>Start the mock server:</p> <pre><code>imposter up examples/graal/simple\n</code></pre> <p>Send a request to the mock server:</p> <pre><code>curl -i http://localhost:8080?name=Ada\n\nHello Ada\n</code></pre>"},{"location":"scripting_modern_js/#advanced-example","title":"Advanced example","text":"<p>See the <code>examples/graal/es6</code> directory for an example of using modern JavaScript features in a script.</p>"},{"location":"scripting_modern_js/#further-reading","title":"Further reading","text":"<ul> <li>Using legacy JavaScript engine (Nashorn)</li> </ul>"},{"location":"security/","title":"Security","text":"<p>This section covers Imposter security. Topics include transport layer security (i.e. HTTPS) and authentication.</p> <p>There are two primary approaches for adding TLS and authentication:</p> <ol> <li>Using Imposter's embedded HTTP server</li> <li>Using a reverse proxy or load balancer in front of Imposter</li> </ol> <p>This section covers the first approach - using the embedded HTTP server. Using a reverse proxy or load balancer is a larger topic outside the scope of this documentation.</p>"},{"location":"security/#tlsssl","title":"TLS/SSL","text":"<p>You can run Imposter with HTTPS enabled. To do this, enable the TLS option and provide keystore options.</p> <p>Read more about how to enable TLS/SSL.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>Imposter can require specific header values to authenticate incoming HTTP requests. To do this, use the <code>security</code> section within the plugin configuration file.</p> <p>Note: this example uses the OpenAPI plugin but the same configuration works with other plugins as well.</p> <pre><code># example-config.yaml\n---\nplugin: openapi\nspecFile: petstore.yaml\n\nsecurity:\n  # no requests permitted by default\n  default: Deny\n\n  # only requests meeting these conditions are permitted\n  conditions:\n  - effect: Permit\n    requestHeaders:\n      Authorization: s3cr3t\n</code></pre>"},{"location":"security/#concepts-and-terminology","title":"Concepts and terminology","text":"<p>Authentication configuration uses the following terms:</p> Term Meaning Examples Condition A property of the request, such as the presence of a specific header value. <code>Authorization</code> header value <code>foo</code> Operator How the condition is matched. <code>EqualTo</code>, <code>NotEqualTo</code>, <code>Matches</code>, <code>NotMatches</code> Effect The impact of the condition on the request, such as it being denied. <code>Permit</code>, <code>Deny</code> <p>The first important concept is the Default Effect. This is the effect that applies to all requests in the absence of a more specific condition. It is good practice to adhere the principle of least privilege. You can achieve this by setting the default effect to <code>Deny</code>, and then adding specific conditions that permit access.</p> <pre><code>security:\n  # no requests permitted by default\n  default: Deny\n</code></pre> <p>This configuration will cause all responses from Imposter to have an <code>HTTP 401 Unauthorized</code> status.</p> <p>Once you have configured the default effect, you typically add Conditions to your security configuration, optionally specifying an Operator.</p> <pre><code>security:\n  # no requests permitted by default\n  default: Deny\n\n  # only requests meeting these conditions are permitted\n  conditions:\n  - effect: Permit\n    requestHeaders:\n      Authorization: s3cr3t\n</code></pre> <p>In this example, Imposter only permits requests that have the following HTTP request header:</p> <pre><code>Authorization: s3cr3t\n</code></pre> <p>Imposter will respond to these requests as normal, but respond to those without this specific header value with <code>HTTP 401 Unauthorized</code> status.  </p> <p>The header name and value is arbitrary - you do not have to use the <code>Authorization</code> header. For example, you could specify:</p> <pre><code>conditions:\n- effect: Permit\n  requestHeaders:\n    X-Custom-Api-Key: s3cr3t\n</code></pre>"},{"location":"security/#supported-conditions","title":"Supported conditions","text":"<p>Imposter supports the following conditions:</p> Condition Meaning Type Example <code>queryParams</code> Request query parameters. Map of String:String <code>{ \"limit\": \"1\" }</code> <code>formParams</code> Request form parameters. Map of String:String <code>{ \"name\": \"Ada\" }</code> <code>requestHeaders</code> Request headers. Map of String:String <code>{ \"Authorization\": \"foo\" }</code> <p>Here's an example showing all conditions:</p> <pre><code>conditions:\n- effect: Permit\n  requestHeaders:\n    X-Custom-Api-Key: s3cr3t\n\n- effect: Deny\n  requestHeaders:\n    X-Forwarded-For:\n      value: 1.2.3.4\n      operator: NotEqualTo\n\n- effect: Permit\n  queryParams:\n    apiKey:\n      value: opensesame\n      operator: EqualTo\n\n- effect: Permit\n  requestHeaders:\n    Authorization:\n      value: Bearer .*\n      operator: Matches\n\n- effect: Deny\n  requestHeaders:\n    Authorization:\n      value: Bearer sometoken\n      operator: NotMatches\n\n- effect: Deny\n  queryParams:\n    apiKey: someblockedkey\n</code></pre>"},{"location":"security/#simple-and-extended-form","title":"Simple and extended form","text":"<p>For each condition you can use the simple form (<code>key: value</code>) or extended form, which allows customisation of matching behaviour.</p> <p>The simple form for conditions is as follows:</p> <pre><code>- effect: Permit\n  queryParams:\n    example: foo\n</code></pre> <p>If you want to control the logical operator you can use the extended form as follows:</p> <pre><code>- effect: Permit\n  queryParams:\n    example:\n      value: foo\n      operator: NotEqualTo\n</code></pre> <p>Here, the value of the <code>example</code> query parameter is specified as a child property named <code>value</code>. The <code>operator</code> is also specified in this form, such as <code>EqualTo</code> or <code>NotEqualTo</code>.</p> <p>Note If no <code>operator</code> is specified, then <code>EqualTo</code> is used.</p> <p>The following operators are supported:</p> Operator Description <code>EqualTo</code> Checks if the condition equals the <code>value</code>. <code>NotEqualTo</code> Checks if the condition does not equal the <code>value</code>. <code>Exists</code> Checks if the condition is not <code>null</code> or absent. <code>NotExists</code> Checks if the condition is <code>null</code> or absent. <code>Contains</code> Checks if the condition contains the <code>value</code>. <code>NotContains</code> Checks if the condition does not contain the <code>value</code>. <code>Matches</code> Checks if the condition matches the regular expression specified in the <code>value</code> field. <code>NotMatches</code> Checks if the condition does not match the regular expression specified in the <code>value</code> field."},{"location":"security/#combining-conditions","title":"Combining conditions","text":"<p>The presence of more than one header in a condition requires all header values match in order for the condition to be satisfied.</p> <pre><code># requests are permitted if both headers match\nconditions:\n- effect: Permit\n  requestHeaders:\n    X-Custom-Api-Key: s3cr3t\n    X-Another-Example: someothervalue\n</code></pre> <p>If you need different effects, use multiple conditions, as follows:</p> <pre><code># requests are permitted if both (1) and (2) are satisfied\nconditions:\n# (1) this header must match\n- effect: Permit\n  requestHeaders:\n    X-Custom-Api-Key: s3cr3t\n\n# (2) this header must not match\n- effect: Deny\n  requestHeaders:\n    X-Another-Example: someothervalue\n</code></pre>"},{"location":"security/#externalising-values-to-environment-variables","title":"Externalising values to environment variables","text":"<p>You can use environment variables to avoid including secrets in your configuration files. For example:</p> <pre><code>conditions:\n- effect: Permit\n  requestHeaders:\n    X-Custom-Api-Key: \"${env.API_KEY}\"\n</code></pre>"},{"location":"security/#security-and-the-status-endpoint","title":"Security and the status endpoint","text":"<p>Imposter has a status endpoint <code>/system/status</code> that is useful as a healthcheck.</p> <p>When you apply a security policy with a default effect of <code>Deny</code>, it also applies to the status endpoint. This will cause requests to <code>/system/status</code> to be denied with <code>HTTP 401</code> status.</p> <p>In cases where you want to permit traffic to the status endpoint without authentication, you can add the following configuration to your OpenAPI plugin or REST plugin configuration:</p> <pre><code># example-config.yaml\n---\nplugin: openapi\nspecFile: petstore.yaml\n\nsecurity:\n  # no requests permitted by default\n  default: Deny\n\nresources:\n  # always permit status endpoint\n  - method: GET\n    path: /system/status\n    security:\n      default: Permit\n</code></pre>"},{"location":"security/#more-examples","title":"More examples","text":"<p>See the <code>examples</code> directory for working sample configurations, such as:</p> <ul> <li>Simple authentication</li> <li>Extended authentication</li> </ul>"},{"location":"sfdc_plugin/","title":"SFDC (Salesforce) plugin","text":"<ul> <li>Plugin name: <code>sfdc</code></li> <li>Plugin class: <code>io.gatehill.imposter.plugin.sfdc.SfdcPluginImpl</code></li> </ul>"},{"location":"sfdc_plugin/#features","title":"Features","text":"<ul> <li>Basic Salesforce mock implementation.</li> <li>Non-persistent SObject creation.</li> <li>Non-persistent SObject update.</li> <li>SObject retrieval by ID.</li> <li>Dummy SOQL queries.</li> </ul>"},{"location":"sfdc_plugin/#install-plugin","title":"Install plugin","text":""},{"location":"sfdc_plugin/#option-1-using-the-cli","title":"Option 1: Using the CLI","text":"<p>To use this plugin, install it with the Imposter CLI:</p> <pre><code>imposter plugin install -d mock-sfdc\n</code></pre> <p>This will install the plugin version matching the current engine version used by the CLI. The next time you run <code>imposter up</code>, the plugin will be available.</p>"},{"location":"sfdc_plugin/#option-2-install-the-plugin-manually","title":"Option 2: Install the plugin manually","text":"<p>To use this plugin, download the <code>imposter-plugin-mock-sfdc.jar</code> JAR file from the Releases page.</p> <p>Enable it with the following environment variables:</p> <pre><code>IMPOSTER_PLUGIN_DIR=\"/path/to/dir/containing/plugin\"\n</code></pre>"},{"location":"sfdc_plugin/#using-the-plugin","title":"Using the plugin","text":"<p>Read the Configuration section to understand how to configure Imposter.</p> <p>Note: Clients interacting with this plugin often require TLS/SSL to be enabled. If this is the case for your client, ensure that you use an https:// scheme for accessing the mock server. See the TLS/SSL section in the TLS/SSL section for more details.</p> <p>Note: Typically, an OAuth2 login step precedes interactions with the SFDC API. As part of this, the mock server is required to return an <code>instance_url</code> to the client. Imposter uses the 'server URL', which is described in the Usage section.</p>"},{"location":"sfdc_plugin/#example","title":"Example","text":"<p>For working examples, see:</p> <pre><code>mock/sfdc/src/test/resources/config\n</code></pre> <p>Let's assume your configuration is in a folder named <code>config</code>.</p> <p>CLI example:</p> <pre><code>imposter up ./config --engine-type docker-all\n</code></pre> <p>Docker example:</p> <pre><code>docker run -ti -p 8080:8080 \\\n    -v $PWD/config:/opt/imposter/config \\\n    outofcoffee/imposter-all \\\n    --serverUrl http://localhost:8080\n</code></pre> <p>Standalone Java example:</p> <pre><code>java -jar distro/all/build/libs/imposter-all.jar \\\n    --configDir ./config \\\n    --serverUrl http://localhost:8080\n</code></pre> <p>This starts a mock server using the SFDC plugin. Responses are served based on the configuration files inside the <code>config</code> folder.</p> <p>Using the example above, you can connect a Salesforce client, such as ForceApi, to http://localhost:8080/ to interact with the API. In this example, you can interact with the <code>Account</code> SObject, as defined in <code>sfdc-plugin-config.json</code> and <code>sfdc-plugin-data.json</code>.</p>"},{"location":"sfdc_plugin/#additional-script-context-objects","title":"Additional script context objects","text":"<p>There are no additional script context objects available.</p>"},{"location":"soap_plugin/","title":"SOAP plugin","text":"<ul> <li>Plugin name: <code>soap</code></li> <li>Plugin class: <code>io.gatehill.imposter.plugin.soap.SoapPluginImpl</code></li> </ul> <p>This plugin provides support for SOAP web services, via WSDL files.</p>"},{"location":"soap_plugin/#features","title":"Features","text":"<ul> <li>Creates mock SOAP web service endpoints from WSDL 1.x and WSDL 2.0 files.</li> <li>Generates responses based on the schema/XSD of the web service invoked.</li> <li>Supports custom responses, headers, status codes etc. based on SOAP operation/binding/action and more.</li> <li>Also supports script-driven responses for maximum control, in either JavaScript or Groovy.</li> </ul>"},{"location":"soap_plugin/#using-the-plugin","title":"Using the plugin","text":"<p>A great way to use this plugin is to take advantage of the request/response types defined in the WSDL types or referenced XSD files. These allow the mock server to generate a response without custom configuration or code, just by parsing the schema of the response message specified in the WSDL types/XSD.</p> <p>This plugin will match the operation using a combination of:</p> <ul> <li>matching URI/path</li> <li>matching HTTP method</li> <li>matching SOAPAction (if required)</li> <li>matching XML schema type of the root element within the request SOAP envelope body </li> </ul> <p>Imposter will return the first response found that matches the above criteria. You can, of course, override the behaviour by setting the response body (see below) or status code.</p> <p>Typically, you will use the configuration file <code>&lt;something&gt;-config.yaml</code> to customise the response, however, you can use the in-built script engine to gain further control of the response data, headers etc.</p>"},{"location":"soap_plugin/#example","title":"Example","text":"<p>Here is an example configuration file:</p> <pre><code># petstore-config.yaml\n---\nplugin: soap\nwsdlFile: petstore.wsdl\n</code></pre> <p>In this example, we are using a WSDL file (<code>petstore.wsdl</code>) containing the following service:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;description xmlns=\"http://www.w3.org/ns/wsdl\"\n             xmlns:tns=\"urn:com:example:petstore\"\n             xmlns:wsoap=\"http://www.w3.org/ns/wsdl/soap\"\n             targetNamespace=\"urn:com:example:petstore\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://www.w3.org/ns/wsdl/soap http://www.w3.org/2002/ws/desc/ns/soap.xsd\"&gt;\n\n    &lt;documentation&gt;\n        This is a sample WSDL 2.0 document describing the pet service.\n    &lt;/documentation&gt;\n\n    &lt;types&gt;\n        &lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n                   xmlns=\"urn:com:example:petstore\"\n                   targetNamespace=\"urn:com:example:petstore\"&gt;\n\n            &lt;xs:import namespace=\"urn:com:example:petstore\"\n                       schemaLocation=\"schema.xsd\"/&gt;\n        &lt;/xs:schema&gt;\n    &lt;/types&gt;\n\n    &lt;interface name=\"PetInterface\"&gt;\n        &lt;fault name=\"Error1\" element=\"tns:fault\"/&gt;\n\n        &lt;operation name=\"getPetById\" pattern=\"http://www.w3.org/ns/wsdl/in-out\"&gt;\n            &lt;wsoap:operation soapAction=\"getPetById\" style=\"document\"/&gt;\n            &lt;input messageLabel=\"In\" element=\"tns:getPetByIdRequest\"/&gt;\n            &lt;output messageLabel=\"Out\" element=\"tns:getPetByIdResponse\"/&gt;\n        &lt;/operation&gt;\n    &lt;/interface&gt;\n\n    &lt;binding name=\"SoapBinding\" interface=\"tns:PetInterface\"\n             type=\"http://www.w3.org/ns/wsdl/soap\"\n             wsoap:protocol=\"http://www.w3.org/2003/05/soap/bindings/HTTP/\"\n             wsoap:mepDefault=\"http://www.w3.org/2003/05/soap/mep/request-response\"&gt;\n        &lt;operation ref=\"tns:getPetById\"/&gt;\n    &lt;/binding&gt;\n\n    &lt;service name=\"PetService\" interface=\"tns:PetInterface\"&gt;\n        &lt;endpoint name=\"SoapEndpoint\"\n                  binding=\"tns:SoapBinding\"\n                  address=\"http://www.example.com/pets/\"/&gt;\n    &lt;/service&gt;\n&lt;/description&gt;\n</code></pre> <p>Some highlights:</p> <ul> <li>We\u2019ve defined the service <code>PetService</code> at the SOAP endpoint <code>/pets/</code></li> <li>We\u2019ve said it has one operation: <code>getPetById</code></li> <li>A request and response ('input' and 'output') message is defined using an external schema (<code>schema.xsd</code>)</li> </ul>"},{"location":"soap_plugin/#start-imposter-with-the-soap-plugin","title":"Start Imposter with the SOAP plugin","text":"<p>The SOAP plugin is bundled with the core Imposter distribution.</p> <p>Let's assume your configuration is in the directory: <code>examples/soap/simple</code>. Here are a few ways to start a mock running on port 8080.</p> <p>CLI example:</p> <pre><code>imposter up ./examples/soap/simple\n</code></pre> <p>Docker example:</p> <pre><code>docker run --rm -ti -p 8080:8080 \\\n    -v $PWD/examples/soap/simple:/opt/imposter/config \\\n    outofcoffee/imposter\n</code></pre> <p>Java JAR example:</p> <pre><code>java -jar distro/core/build/libs/imposter-core.jar \\\n    --configDir ./examples/soap/simple\n</code></pre> <p>This starts a mock server using the SOAP plugin. Responses are served based on the WSDL file and its referenced XSD file <code>schema.xsd</code>.</p> <p>Using the example above, you can interact with the APIs in the SOAP web service at their respective endpoints under <code>http://localhost:8080/pets/</code>.</p> <p>Send a SOAP request to the <code>/pets/</code> path defined in the configuration file to see the example response:</p> <pre><code>$ curl -X POST \"http://localhost:8080/pets/\" \\\n    -H 'Content-Type: application/soap+xml' \\\n    -d '&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n        &lt;env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\"&gt;\n            &lt;env:Header/&gt;\n            &lt;env:Body&gt;\n                &lt;getPetByIdRequest xmlns=\"urn:com:example:petstore\"&gt;\n                    &lt;id&gt;3&lt;/id&gt;\n                &lt;/getPetByIdRequest&gt;\n            &lt;/env:Body&gt;\n        &lt;/env:Envelope&gt;'\n</code></pre> <p>Tip: don't forget the trailing quote at the end of the string!</p> <p>Response: <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\"&gt;\n    &lt;env:Header/&gt;\n    &lt;env:Body&gt;\n        &lt;getPetByIdResponse xmlns=\"urn:com:example:petstore\"&gt;\n            &lt;id&gt;3&lt;/id&gt;\n            &lt;name&gt;string&lt;/name&gt;\n        &lt;/getPetByIdResponse&gt;\n    &lt;/env:Body&gt;\n&lt;/env:Envelope&gt;\n</code></pre></p> <p>It works! Your mock is returning an example SOAP response at the path <code>/pets/</code>, all from Imposter understanding the WSDL file.</p> <p>Once you're finished, stop the server with CTRL+C.</p> <p>For more working examples, see:</p> <ul> <li>examples/soap</li> </ul>"},{"location":"soap_plugin/#conditional-responses","title":"Conditional responses","text":"<p>You can control response behaviour based on the value of the request path, SOAP binding, SOAP operation, SOAPAction or body content.</p> <pre><code># custom-response-config.yaml\n---\nplugin: soap\nwsdlFile: petstore.wsdl\n\nresources:\n  # return custom response body for a given operation\n  - path: \"/pets/\"\n    operation: getPetById\n    response:\n      file: getPetByIdResponse.xml\n\n  # return HTTP 400 response if SOAPAction matches a specific value\n  - path: \"/pets/\"\n    soapAction: \"invalid-pet-action\"\n    response:\n      statusCode: 400\n</code></pre>"},{"location":"soap_plugin/#first-example","title":"First example","text":"<p>Here we expect the content of the file: <code>getPetByIdResponse.xml</code>.</p> <pre><code>$ curl -v -X POST http://localhost:8080/pets/ \\\n    -H 'Content-Type: application/soap+xml' \\\n    -d '&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n        &lt;env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\"&gt;\n            &lt;env:Header/&gt;\n            &lt;env:Body&gt;\n                &lt;getPetByIdRequest xmlns=\"urn:com:example:petstore\"&gt;\n                    &lt;id&gt;3&lt;/id&gt;\n                &lt;/getPetByIdRequest&gt;\n            &lt;/env:Body&gt;\n        &lt;/env:Envelope&gt;'\n</code></pre> <p>Response: <pre><code>HTTP/1.1 200 OK\n...\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\"&gt;\n    &lt;env:Header/&gt;\n    &lt;env:Body&gt;\n        &lt;getPetByIdResponse xmlns=\"urn:com:example:petstore\"&gt;\n            &lt;id&gt;3&lt;/id&gt;\n            &lt;name&gt;Custom pet name&lt;/name&gt;\n        &lt;/getPetByIdResponse&gt;\n    &lt;/env:Body&gt;\n&lt;/env:Envelope&gt;\n</code></pre></p>"},{"location":"soap_plugin/#second-example","title":"Second example","text":"<p>Here we expect an HTTP 400 status code, given the matching SOAPAction.</p> <pre><code>$ curl -v -X POST http://localhost:8080/pets/ -H 'SOAPAction: invalid-pet-action'\nHTTP/1.1 400 Bad Request\n</code></pre>"},{"location":"soap_plugin/#returning-fault-messages","title":"Returning fault messages","text":"<p>If your WSDL document defines a <code>fault</code>, then Imposter can generate a sample response from its type.</p> <p>To return a fault you can:</p> <ol> <li>set the response status code to <code>500</code>, or</li> <li>set the <code>response.soapFault</code> configuration property to <code>true</code>, or</li> <li>use the <code>respond().withSoapFault()</code> script function</li> </ol>"},{"location":"soap_plugin/#example-configuration-to-respond-with-a-fault","title":"Example configuration to respond with a fault","text":"<pre><code>plugin: soap\nwsdlFile: service.wsdl\n\nresources:\n  - binding: SoapBinding\n    operation: getPetById\n    response:\n      statusCode: 500\n</code></pre> <p>Tip Use conditional matching with resources, to only return a fault in particular circumstances. See fault-example for an example of how to do this.</p>"},{"location":"soap_plugin/#scripted-responses-advanced","title":"Scripted responses (advanced)","text":"<p>For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts.</p> <p>See the Scripting section for more information.</p> <p>For a simple script, see examples/soap/scripted-example for a working example.</p>"},{"location":"soap_plugin/#additional-context-objects","title":"Additional context objects","text":"<p>This plugin adds objects to the script <code>context</code>:</p> Object Type Description <code>binding</code> <code>io.gatehill.imposter.plugin.soap.model.WsdlBinding</code> The SOAP binding for the request. <code>operation</code> <code>io.gatehill.imposter.plugin.soap.model.WsdlOperation</code> The SOAP operation for the request. <code>soapAction</code> <code>String?</code> The SOAPAction from the request, if supplied by the client."},{"location":"soap_plugin/#example_1","title":"Example","text":"<p>Here we set the <code>response.scriptFile</code> property in the configuration file:</p> <pre><code># scripted-soap-config.yaml\n---\nplugin: soap\nwsdlFile: petstore.wsdl\nresponse:\n  scriptFile: example.groovy\n</code></pre> <p>As a reminder, you can use either JavaScript (<code>.js</code>) or Groovy (<code>.groovy</code>) languages for your scripts.</p> <p>Now, <code>example.groovy</code> can control the responses, such as:</p>"},{"location":"soap_plugin/#return-the-content-of-a-file","title":"Return the content of a file","text":"<pre><code>respond().withFile('some-file.xml')\n</code></pre>"},{"location":"soap_plugin/#return-a-literal-string","title":"Return a literal string","text":"<pre><code>respond().withContent('''&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\"&gt;\n &lt;env:Header/&gt;\n &lt;env:Body&gt;\n     &lt;getPetByIdResponse xmlns=\"urn:com:example:petstore\"&gt;\n         &lt;id&gt;3&lt;/id&gt;\n         &lt;name&gt;Custom pet name&lt;/name&gt;\n     &lt;/getPetByIdResponse&gt;\n &lt;/env:Body&gt;\n&lt;/env:Envelope&gt;\n''')\n</code></pre>"},{"location":"soap_plugin/#return-a-specific-http-status-code","title":"Return a specific HTTP status code","text":"<p>Setting the status code to 500 will trigger a fault message to be returned if one is defined within the WSDL document.</p> <pre><code>respond().withStatusCode(500)\n</code></pre>"},{"location":"soap_plugin/#scripting-examples","title":"Scripting examples","text":"<ul> <li>conditional-example</li> <li>scripted-example</li> <li>fault-example</li> </ul>"},{"location":"soap_plugin/#configuration-reference","title":"Configuration reference","text":"<p>In addition to the standard configuration file options, the following additional properties are supported.</p> Configuration name Purpose Default value <code>path</code> (Optional) A string to prepend to each operation's path. Empty <code>wsdlFile</code> (Required) path to WSDL file (see below). Empty"},{"location":"soap_plugin/#wsdl-file-locations","title":"WSDL file locations","text":"<p>WSDL files are provided as a relative path, using the directory containing the referencing configuration file as a base.</p> <p>Some examples:</p> <p>A file in the same directory as the configuration file:</p> <pre><code>plugin: soap\nwsdlFile: sample_service.wsdl\n</code></pre> <p>A file in a subdirectory relative to the configuration file:</p> <pre><code>plugin: soap\nwsdlFile: ./services/sample_service.wsdl\n</code></pre>"},{"location":"soap_plugin/#xsd-file-locations","title":"XSD file locations","text":"<p>XSD files are often used to describe the schema used by the operations in the WSDL file. When parsing a WSDL file, Imposter loads the content of all XSD files in the same directory as the WSDL file. This means that all XSD types defined in those files are used to support resolution of types referenced from the WSDL file.</p> <p>For example:</p> <pre><code>$ ls\nimposter-config.yaml  service.wsdl  schema.xsd  another_schema.xsd\n</code></pre> <p>If the <code>imposter-config.yaml</code> file is as follows, then both XSD files will be read to build the schema for the mock SOAP service.</p> <pre><code>plugin: soap\nwsdlFile: service.wsdl\n</code></pre>"},{"location":"steps/","title":"Steps","text":"<p>Imposter can perform actions when it receives a request. These actions are called Steps; they take input, perform an operation, and, optionally, produce output.</p> <p>Steps can call external systems, run scripts and use stores. You can define as many steps as you need. Steps are executed in the order they are defined in the configuration file.</p> <p>Steps can use data from the current request, access stores, or use the output of previous steps. Step outputs can be used in mock responses, such as in a response template, or to drive conditional logic.</p>"},{"location":"steps/#step-types","title":"Step Types","text":"<p>Imposter supports the following step types:</p> <ul> <li>Execute a script</li> <li>Make an HTTP(S) request to a server</li> </ul>"},{"location":"steps/#execute-a-script","title":"Execute a script","text":"<p>The <code>script</code> step type allows you to execute a script. The script has access to the request context and stores. Script code can be inline or in an external file.</p> <p>Note See the scripting section for more information about writing scripts.</p>"},{"location":"steps/#inline-script","title":"Inline script","text":"<p>Here is an example of an inline script.</p> <p>Note Inline scripts can be written in JavaScript or Groovy. Set the <code>lang</code> property to either <code>javascript</code> or <code>groovy</code></p> <pre><code># ...part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  steps:\n    - type: script\n      lang: javascript\n      code: console.log('Hello World!');\n</code></pre>"},{"location":"steps/#explanation","title":"Explanation","text":"<p>Calling the endpoint <code>/example</code> with a <code>GET</code> request will cause the inline JavaScript code to be executed.</p> <p>The code prints <code>Hello World!</code> to the console.</p>"},{"location":"steps/#multiline-inline-scripts","title":"Multiline inline scripts","text":"<p>The <code>code</code> property can support multi-line YAML strings, such as:</p> <pre><code># ...part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  steps:\n    - type: script\n      lang: javascript\n      code: |\n        console.log('Hello World!');\n        console.log('This is a second line');\n</code></pre>"},{"location":"steps/#external-script","title":"External script","text":"<p>Scripts can be stored in an external file. Here is an example of an external script.</p> <p>Note External scripts can be written in JavaScript or Groovy.</p> <p>Let's assume you have a file named <code>example.js</code> with the following content:</p> <pre><code>console.log('Hello World!');\n</code></pre> <p>Your step configuration would look like this:</p> <pre><code># ...part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  steps:\n    - type: script\n      file: example.js\n</code></pre>"},{"location":"steps/#explanation_1","title":"Explanation","text":"<p>Calling the endpoint <code>/example</code> with a <code>GET</code> request will cause the external JavaScript file <code>example.js</code> to be executed.</p> <p>The code prints <code>Hello World!</code> to the console.</p>"},{"location":"steps/#make-an-https-request-to-a-server","title":"Make an HTTP(S) request to a server","text":"<p>The <code>remote</code> step type allows you to make an HTTP(S) request to a server. The response, including headers and body, can be in response templates, captured in a store or used in later steps.</p>"},{"location":"steps/#example-send-a-request","title":"Example: Send a request","text":"<p>Here is an example of a configuration file with a simple <code>remote</code> step:</p> <pre><code># ...part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  steps:\n    - type: remote\n      url: http://example.com\n      method: GET\n</code></pre>"},{"location":"steps/#explanation_2","title":"Explanation","text":"<p>Calling the endpoint <code>/example</code> with a <code>GET</code> request will cause Imposter to send an HTTP request to <code>http://example.com</code>.</p> <p>Since no <code>capture</code> section is defined, the response will not be stored.</p>"},{"location":"steps/#example-send-a-request-and-store-the-response","title":"Example: Send a request and store the response","text":"<p>Here is an example of a configuration file with a <code>remote</code> step that captures the response body:</p> <pre><code># ...part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  steps:\n    - type: remote\n      url: http://example.com\n      method: GET\n      capture:\n        responseBody:\n          expression: \"${remote.response.body}\"\n\n  response:\n    content: \"The upstream response was: ${stores.request.responseBody}\"\n</code></pre>"},{"location":"steps/#explanation_3","title":"Explanation","text":"<p>Calling the endpoint <code>/example</code> with a <code>GET</code> request will cause Imposter to send an HTTP request to <code>http://example.com</code>.</p> <p>Since a <code>capture</code> block is defined, the response status code and body will be held in the <code>request</code> store.</p> <p>As with all stores, you can use data in response templates, scripts, or access the data in subsequent steps.</p> <p>In this example, the mock response will contain the body of the response from <code>http://example.com</code> prefixed with the string <code>The upstream response was:</code>.</p>"},{"location":"steps/#multiple-captures","title":"Multiple captures","text":"<p>You can capture multiple parts of the response by adding more properties to the <code>capture</code> block.</p> <p>For example, to capture the status code and the response body:</p> <pre><code># ...part of your configuration file\ncapture:\n  statusCode:\n    expression: \"${remote.response.statusCode}\"\n  responseBody:\n    expression: \"${remote.response.body}\"\n</code></pre> <p>In this example, both the <code>statusCode</code> and <code>responseBody</code> properties will be stored in the <code>request</code> store. You can then use these properties in subsequent steps or in response templates, by referencing the store properties, such as <code>${stores.request.statusCode}</code>.</p>"},{"location":"steps/#further-examples","title":"Further examples","text":"<p>This section contains further examples of using steps, including multiple steps and using stores.</p>"},{"location":"steps/#example-use-previous-step-output-in-a-later-step","title":"Example: Use previous step output in a later step","text":"<p>Here is an example of a configuration file with multiple steps:</p> <pre><code># ...part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  steps:\n    # the first step will send an HTTP request to example.com\n    # and store its response status code and body in the 'request' store\n    - type: remote\n      url: http://example.com\n      method: GET\n      capture:\n        statusCode:\n          expression: \"${remote.response.statusCode}\"\n        responseBody:\n          expression: \"${remote.response.body}\"\n\n    # the second step will log the status code of the response\n    - type: script\n      lang: javascript\n      code: |\n        console.log('Remote HTTP response status code: ' + stores.request.statusCode);\n</code></pre> <p>Note Remember that the <code>request</code> store is ephemeral, and holds values for the current, in-flight request. See the Stores documentation for details.</p>"},{"location":"steps/#example-use-previous-step-output-in-the-mock-response","title":"Example: Use previous step output in the mock response","text":"<p>Here is an example of a configuration file with multiple steps:</p> <pre><code># ...part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  steps:\n    # send an HTTP request to example.com\n    # and store its response status code and body in the 'request' store\n    - type: remote\n      url: http://example.com\n      method: GET\n      capture:\n        statusCode:\n          expression: \"${remote.response.statusCode}\"\n        responseBody:\n          expression: \"${remote.response.body}\"\n\n  # the mock response will be the content of the response body\n  # returned by the call to `http://example.com`\n  response:\n    content: \"${stores.request.responseBody}\"\n</code></pre> <p>Note Remember that the <code>request</code> store is ephemeral, and holds values for the current, in-flight request. See the Stores documentation for details.</p>"},{"location":"stores/","title":"Stores","text":"<p>Imposter allows you to store data for use later. Benefits:</p> <ul> <li>use data from a request in a current or future response</li> <li>store the data sent to a mock for later retrieval/verification</li> <li>set up or seed test data before a mock is used</li> <li>capture data (headers, body etc.) for use by a script</li> <li>return stored data in a response template</li> <li>support for GraphQL queries</li> </ul>"},{"location":"stores/#summary","title":"Summary","text":"<p>You can access Stores via an object in scripts, named <code>stores</code>, and the <code>/system/store</code> REST API. </p>"},{"location":"stores/#using-stores-in-scripts","title":"Using stores in scripts","text":"<p>Here is an example of using the <code>stores</code> object in your scripts.</p> <pre><code>var exampleStore = stores.open('example');\n\n// save the value of the 'foo' query parameter to the store\nexampleStore.save('foo', context.request.queryParams.foo);\n\n// ...in some other request, later\nvar previousFoo = exampleStore.load('foo');\nrespond()\n  .withStatusCode(200)\n  .withContent(previousFoo);\n</code></pre> <p>Stores also support deletion:</p> <pre><code>exampleStore.delete('example');\n</code></pre> <p>and retrieving all data:</p> <pre><code>var storeData = exampleStore.loadAll();\nlogger.info('foo=' + storeData.foo);\nlogger.info('bar=' + storeData.bar);\n</code></pre> <p>You can check for the presence of an item by key:</p> <pre><code>if (exampleStore.hasItemWithKey('example')) {\n    // ... there is an item with the key 'example'\n}\n</code></pre> <p>Read a store item as JSON:</p> <pre><code>var json = exampleStore.loadAsJson('foo');\n\n// prints the 'foo' item as JSON\nconsole.log(json);\n</code></pre>"},{"location":"stores/#the-stores-rest-api","title":"The Stores REST API","text":"<p>You can also retrieve or save data to a store through the <code>/system/store</code> API. This can be useful for tests to verify what was sent to a mock:</p> <pre><code>$ curl http://localhost:8080/system/store/test/foo\nada\n</code></pre> <p>In this example, imagine the item <code>foo</code> in the <code>test</code> store was set to the value <code>ada</code> by a previous request or script (see above).</p> <p>You can also set data via this API:</p> <pre><code>$ curl -XPUT --data 'ada' http://localhost:8080/system/store/test/foo\n</code></pre> <p>Your scripts can now use the data in the store. This can be useful for test data setup/seeding.</p> <p>You can retrieve all the items in a store:</p> <pre><code>$ curl http://localhost:8080/system/store/test\n{\n  \"foo\": \"ada\",\n  \"bar\": \"baz\"\n}\n</code></pre> <p>Note, you can filter the items returned by their key's prefix, such as:</p> <pre><code>$ curl http://localhost:8080/system/store/test?keyPrefix=fo\n{\n  \"foo\": \"ada\"\n}\n</code></pre> <p>You can delete items in a store:</p> <pre><code>$ curl -XDELETE http://localhost:8080/system/store/test/foo\n</code></pre> <p>This deletes the <code>foo</code> item from the <code>test</code> store.</p> <p>You can delete an entire store and all of its data:</p> <pre><code>$ curl -XDELETE http://localhost:8080/system/store/test\n</code></pre> <p>This deletes the whole <code>test</code> store and all its data.</p> <p>You can set multiple items at once via a <code>POST</code> to the store resource:</p> <pre><code>$ curl -XPOST http://localhost:8080/system/store/test --data '{ \"foo\": \"bar\", \"baz\": \"qux\" }'\n</code></pre>"},{"location":"stores/#environment-variables","title":"Environment variables","text":"<p>The following environment variables are supported:</p> Variable name Purpose Default Example(s) IMPOSTER_STORE_DRIVER Sets the store implementation (see Store implementations section). <code>store-inmem</code> <code>store-dynamodb</code> IMPOSTER_STORE_KEY_PREFIX Sets an optional prefix for all keys in the store, like a namespace. Empty A prefix of <code>foo</code> would result in the key <code>bar</code> being stored as <code>foo.bar</code>"},{"location":"stores/#request-scoped-store","title":"Request scoped store","text":"<p>There is a special request-scoped store, named <code>request</code>, which is accessible only to the current request. Its contents do not persist beyond the lifecycle of the request.</p> <p>The request scoped store is very useful when you need to capture an item for immediate use, such as in a response template, but you don't need to persist it for later use.</p>"},{"location":"stores/#preloading-pre-populating-data-into-a-store","title":"Preloading (pre-populating) data into a store","text":"<p>You can preload data into a store when Imposter starts.</p> <p>To do this, use the <code>system.stores.preloadFile</code> or <code>system.stores.preloadData</code> key in a configuration file.</p>"},{"location":"stores/#preloading-from-file","title":"Preloading from file","text":"<p>Typically, you will provide the data in a JSON file, and use the <code>preloadFile</code> key:</p> <pre><code>plugin: rest\n\nsystem:\n  stores:\n    # this store is preloaded from file\n    example:\n      preloadFile: initial-data.json\n</code></pre> <p>In the above example, the contents of the file <code>initial-data.json</code> will be loaded into the store named 'example'.</p> <p>This file contains a JSON object, such as the following:</p> <pre><code>{\n  \"foo\": \"bar\",\n  \"baz\": {\n    \"qux\": \"corge\"\n  }\n}\n</code></pre> <p>Note that you can store child objects, but the top level keys must always be a string.</p>"},{"location":"stores/#preloading-from-inline-data","title":"Preloading from inline data","text":"<p>If you have a small amount of data, or you don't want to use a separate file, you can provide the preload data inline within a configuration file using the <code>preloadData</code> key:</p> <pre><code>plugin: rest\n\nsystem:\n  stores:\n    # this store is preloaded from inline data\n    example:\n      preloadData:\n        foo: bar\n        baz: { \"qux\": \"corge\" }\n</code></pre> <p>In the above example, the items under <code>preloadData</code> block will be loaded into the store named 'example'.</p> <p>You must provide an object with key/value pairs, such as that shown above, or in the JSON file below. Top level keys must always be a string.</p>"},{"location":"stores/#store-implementations","title":"Store implementations","text":"<p>Different store implementations exist:</p> <ul> <li>In memory store (default)</li> <li>DynamoDB store</li> <li>Redis store</li> </ul>"},{"location":"stores/#graphql-support","title":"GraphQL support","text":"<p>As well as the stores REST API described in this document, you can access and manipulate data using GraphQL.</p>"},{"location":"stores_graphql/","title":"GraphQL store queries","text":"<p>When using Stores, you can access and manipulate data using the Stores REST API, or using GraphQL.</p> <p>See the Stores documentation for information about its REST API.</p> <p>Supported features:</p> <ul> <li>Query items by store</li> <li>Filter items by key prefix</li> </ul>"},{"location":"stores_graphql/#install-graphql-plugin","title":"Install GraphQL plugin","text":"<p>Imposter provides GraphQL support using a plugin.</p>"},{"location":"stores_graphql/#option-1-install-plugin-using-the-cli","title":"Option 1: Install plugin using the CLI","text":"<p>To use this plugin, install it with the Imposter CLI:</p> <pre><code>imposter plugin install -d store-graphql\n</code></pre> <p>This will install the plugin version matching the current engine version used by the CLI. The next time you run <code>imposter up</code>, the plugin will be available.</p>"},{"location":"stores_graphql/#option-2-install-the-plugin-manually","title":"Option 2: Install the plugin manually","text":"<p>To use this plugin, download the <code>imposter-plugin-store-graphql.jar</code> JAR file from the Releases page.</p> <p>Enable it with the following environment variables:</p> <pre><code>IMPOSTER_PLUGIN_DIR=\"/path/to/dir/containing/plugin\"\n</code></pre>"},{"location":"stores_graphql/#execute-a-graphql-query","title":"Execute a GraphQL query","text":"<p>The GraphQL query endpoint is <code>/system/store/graphql</code>, for example:</p> <pre><code>http://localhost:8080/system/store/graphql\n</code></pre> <p>Here is a query to retrieve all items in a given store:</p> <pre><code>query {\n  items(storeName: \"test\") {\n    key\n    value\n  }\n}\n</code></pre> <p>This yields the following result:</p> <pre><code>{\n  \"data\": {\n    \"items\": [\n      { \"key\":  \"foo\", \"value\":  \"bar\" },\n      { \"key\":  \"baz\", \"value\":  \"qux\" }\n    ]\n  }\n}\n</code></pre> <p>You can filter the items returned via a key prefix:</p> <pre><code>query {\n  items(storeName: \"test\", keyPrefix: \"f\") {\n    key\n    value\n  }\n}\n</code></pre> <p>This yields a single result, with the key matching the prefix <code>\"f\"</code>:</p> <pre><code>{\n  \"data\": {\n    \"items\": [\n      { \"key\":  \"foo\", \"value\":  \"bar\" }\n    ]\n  }\n}\n</code></pre>"},{"location":"summary/","title":"Product summary","text":"<p>Imposter is a mock server for REST APIs, OpenAPI (and Swagger) specifications, SOAP web services (and WSDL files), Salesforce and HBase APIs.</p> <ul> <li>Run standalone mock servers in Docker, Kubernetes, AWS Lambda or on the JVM.</li> <li>Embed mocks within your tests (JVM or Node.js) to remove external dependencies.</li> <li>Script dynamic responses using JavaScript, Groovy or Java.</li> <li>Capture data from requests, then store it or return a templated response.</li> <li>Proxy an existing endpoint to replay its responses as a mock.</li> </ul>"},{"location":"summary/#getting-started","title":"Getting started","text":"<p>To begin, check out our Getting started guide. See the User documentation for more.</p>"},{"location":"summary/#highlights","title":"Highlights","text":"<ul> <li>run standalone mocks in place of real systems</li> <li>turn an OpenAPI/Swagger file or WSDL file into a mock API for dev or QA (use it before the real API is built)</li> <li>decouple your integration tests from the cloud/back-end systems and take control of your dependencies</li> <li>validate your API requests against an OpenAPI specification</li> <li>capture data to retrieve later, or use in templates to for conditional responses</li> <li>proxy an existing endpoint to replay its responses as a mock</li> </ul> <p>Send dynamic responses:</p> <ul> <li>Provide mock responses using static files or customise behaviour based on characteristics of the request.</li> <li>Power users can control mock responses with JavaScript or Java/Groovy script engines.</li> <li>Advanced users can write their own plugins in a JVM language of their choice.</li> </ul>"},{"location":"summary/#mock-types","title":"Mock types","text":"<p>Imposter provides specialised mocks for the following scenarios:</p> <ul> <li>OpenAPI - Support for OpenAPI (and Swagger) API specifications.</li> <li>REST - Mocks RESTful or plain HTTP APIs.</li> <li>SOAP - Support for SOAP web services (and WSDL files).</li> <li>HBase - Basic HBase mock implementation.</li> <li>SFDC (Salesforce) - Basic Salesforce mock implementation.</li> <li>WireMock - Support for WireMock mappings files.</li> </ul>"},{"location":"template_queries/","title":"Response template queries","text":"<p>Imposter allows you to respond with a template - that is, a file or content containing placeholders, which are replaced with values at runtime. See the templates page for more information.</p> <p>You can also use a JsonPath expression to query an object when using a placeholder.</p> <p>This is useful if you have an object, such as a request body or object within a store, and wish to render a child property of the object instead of the whole object.</p>"},{"location":"template_queries/#using-jsonpath-in-placeholders","title":"Using JsonPath in placeholders","text":"<p>The JsonPath placeholder syntax is as follows:</p> <pre><code>&lt;placeholder expression&gt;:&lt;JsonPath expression&gt;\n</code></pre> <p>Here is an example that queries the request body:</p> <pre><code>${context.request.body:$.name}\n</code></pre> <p>In this example, the request body is parsed as a JSON object, then the JsonPath expression <code>$.name</code> is executed. The request body looks like this:</p> <pre><code>{\n  \"name\": \"Alice\",\n  \"occupation\": \"Programmer\"\n}\n</code></pre> <p>The result of the query is the string <code>Alice</code>, which is then substituted into the template.</p> <p>Similarly, you could refer to other properties of the body - <code>occupation</code> would look like this:</p> <pre><code>Your occupation is: ${context.request.body:$.occupation}\n</code></pre>"},{"location":"template_queries/#example-using-stores","title":"Example using stores","text":"<p>This example fetches an item in a store, and returns the <code>name</code> property using a JsonPath expression.</p> <p>Learn more about stores.</p> <p>This will return the <code>name</code> property from the <code>person</code> item in the <code>request</code> store:</p> <pre><code>${stores.request.person:$.name}\n</code></pre> <p>This retrieves the item named <code>person</code> from the <code>request</code> store. The item must be an object, or a string representation of a valid JSON object.</p> <p>The <code>person</code> item looks like this:</p> <pre><code>{\n  \"name\": \"Alice\",\n  \"occupation\": \"Programmer\"\n}\n</code></pre> <p>Since this item is an object, we can use JsonPath to query the <code>name</code> property - hence the expression <code>$.name</code> in the template placeholder.</p>"},{"location":"template_queries/#templating-performance","title":"Templating performance","text":"<p>Using JsonPath in placeholder templates is computationally expensive, as it requires parsing and querying of an item rather than just value substitution.</p>"},{"location":"template_queries/#examples","title":"Examples","text":"<ul> <li>response-template</li> </ul>"},{"location":"templates/","title":"Response templates","text":"<p>Imposter allows you to respond with a template - that is, a file or content containing placeholders, which are replaced with values at runtime.</p> <p>Templates can be useful when you are capturing data, using stores or generating data from a script.</p> <p>Templates can be used with configuration or scripts.</p>"},{"location":"templates/#key-concepts","title":"Key concepts","text":"<p>The template engine is enabled by setting <code>template: true</code> in a resource. For example:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  response:\n    template: true\n    file: some-template.txt\n</code></pre> <p>Templates can be specified as external files, or inline in configuration files.</p> <p>Here is the same example as above, but using an inline <code>content</code> block:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /example\n  method: GET\n  response:\n    template: true\n    content: |\n      Hello ${context.request.pathParams.user}\n      This is a templated response.\n</code></pre> <p>There are many placeholder types (see placeholder types section), including:</p> <ul> <li>properties of the request, such as path parameters, query parameters, headers or body</li> <li>date/time values, such as timestamps, epoc time in millis, nanos etc.</li> <li>data from Stores, including data captured previously</li> <li>generating random values, such as UUIDs, numbers, strings etc.</li> <li>generating fake data, such as names, addresses, phone numbers etc.</li> <li>properties of the Imposter system, such as the server port or server URL</li> </ul>"},{"location":"templates/#placeholder-types","title":"Placeholder types","text":"<p>This section details the placeholder types.</p>"},{"location":"templates/#request-path-parameters","title":"Request path parameters","text":"<p>Syntax: <code>context.request.pathParams.&lt;param name&gt;</code></p> <p>Example config:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /users/{user}\n  method: GET\n  response:\n    content: \"Hello ${context.request.pathParams.user}\"\n    template: true\n</code></pre> <p>Example request:</p> <pre><code>$ curl http://localhost:8080/users/alice\n\nHello alice\n</code></pre>"},{"location":"templates/#request-query-parameters","title":"Request query parameters","text":"<p>Syntax: <code>context.request.queryParams.&lt;param name&gt;</code></p> <p>Example config:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /users\n  method: GET\n  response:\n    content: \"Hello ${context.request.queryParams.user}\"\n    template: true\n</code></pre> <p>Example request:</p> <pre><code>$ curl http://localhost:8080/users?user=alice\n\nHello alice\n</code></pre>"},{"location":"templates/#request-headers","title":"Request headers","text":"<p>Syntax: <code>context.request.headers.&lt;header name&gt;</code></p> <p>Example config:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /users\n  method: GET\n  response:\n    content: \"Hello ${context.request.headers.user}\"\n    template: true\n</code></pre> <p>Example request:</p> <pre><code>$ curl http://localhost:8080/users -H \"user: alice\"\n\nHello alice\n</code></pre>"},{"location":"templates/#request-body","title":"Request body","text":"<p>Syntax: <code>context.request.body</code></p> <p>Example config:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /users\n  method: POST\n  response:\n    content: \"Hello ${context.request.body}\"\n    template: true\n</code></pre> <p>Example request:</p> <pre><code>$ curl http://localhost:8080/users --data \"alice\"\n\nHello alice\n</code></pre> <p>Note: the use of curl's <code>--data</code> argument implies this is a <code>POST</code> request, with the value <code>alice</code> sent as the request body.</p>"},{"location":"templates/#request-form-parameters","title":"Request form parameters","text":"<p>Syntax: <code>context.request.formParams.&lt;param name&gt;</code></p> <p>Example config:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /users\n  method: POST\n  response:\n    content: \"Hello ${context.request.formParams.user}\"\n    template: true\n</code></pre> <p>Example request:</p> <pre><code>$ curl http://localhost:8080/users --data-urlencode \"user=alice\"\n\nHello alice\n</code></pre>"},{"location":"templates/#other-request-attributes","title":"Other request attributes","text":"<p>Other request attributes are available:</p> Attribute Meaning Example <code>context.request.path</code> The HTTP request path. <code>/example</code> <code>context.request.uri</code> The full URI of the HTTP request. <code>http://localhost:8080/example</code>"},{"location":"templates/#datetime-values","title":"Date/time values","text":"<p>Syntax: <code>datetime.now.&lt;property&gt;</code></p> <p>Example config:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /now\n  method: GET\n  response:\n    content: \"The date is ${datetime.now.iso8601_date}\"\n    template: true\n</code></pre> <p>Example request:</p> <pre><code>$ curl http://localhost:8080/now\n\nThe date is 2022-12-28\n</code></pre> <p>Valid date/time properties:</p> Syntax Example Example value <code>datetime.now.iso8601_date</code> <code>${datetime.now.iso8601_date}</code> <code>\"2022-01-20\"</code> <code>datetime.now.iso8601_datetime</code> <code>${datetime.now.iso8601_datetime}</code> <code>\"2022-01-20T14:23:25.737Z\"</code> <code>datetime.now.millis</code> <code>${datetime.now.millis}</code> <code>\"1642688570140\"</code> <code>datetime.now.nanos</code> <code>${datetime.now.nanos}</code> <code>\"30225267785430\"</code>"},{"location":"templates/#random-values","title":"Random values","text":"<p>Syntax: <code>random.&lt;function&gt;</code></p> <p>Example config:</p> <pre><code># part of your configuration file\n\nresources:\n- path: /number\n  method: GET\n  response:\n    content: \"An integer is ${random.numeric()}\"\n    template: true\n\n- path: /chars\n  method: GET\n  response:\n    content: \"A random string is ${random.alphabetic(length=5)}\"\n    template: true\n</code></pre> <p>Example requests:</p> <pre><code>$ curl http://localhost:8080/number\nAn integer is 4\n\n$ curl http://localhost:8080/chars\nA random string is abcde\n</code></pre> <p>Valid random functions:</p> Syntax Example Example value <code>random.alphabetic()</code> <code>${random.alphabetic()}</code> <code>\"i\"</code> <code>random.alphanumeric()</code> <code>${random.alphanumeric()}</code> <code>\"i\"</code> or <code>\"42\"</code> <code>random.any(chars=\"...\")</code> <code>${random.any(chars=\"abc123\")}</code> <code>\"a\"</code> or <code>\"1\"</code> <code>random.numeric()</code> <code>${random.numeric()}</code> <code>\"42\"</code> <code>random.uuid()</code> <code>${random.uuid()}</code> <code>\"e1a4fba9-33eb-4241-84cf-472f90639c37\"</code> <p>Note: the syntax for <code>random</code> is slightly different to the other placeholder types. These are functions, not properties, so are called with parentheses.</p>"},{"location":"templates/#customise-length","title":"Customise length","text":"<p>Customise the length of the generated value by passing <code>length=NUM</code> argument into the function.</p> <p>For example: <code>${random.alphabetic(length=5)}</code> will generate a 5-character alphabetic string.</p> <p>The default length is 1.</p> <p>This applies to the following functions:</p> <ul> <li>alphabetic</li> <li>alphanumeric</li> <li>any</li> <li>numeric</li> </ul>"},{"location":"templates/#uppercase","title":"Uppercase","text":"<p>Convert the generated value to uppercase by passing <code>uppercase=true</code> argument into the function.</p> <p>For example: <code>${random.alphabetic(uppercase=true)}</code> will generate an uppercase alphabetic character.</p> <p>You can combine <code>length</code> and <code>uppercase</code> arguments.</p> <p>For example: <code>${random.alphabetic(length=5, uppercase=true)}</code> will generate a 5-character uppercase alphabetic string.</p>"},{"location":"templates/#generate-from-a-set-of-characters","title":"Generate from a set of characters","text":"<p>Generate a value from a set of characters by passing <code>chars=\"...\"</code> argument into the <code>random.any()</code> function.</p> <p>For example: <code>${random.any(chars=\"abc123\")}</code> will generate a value from the set of characters <code>a</code>, <code>b</code>, <code>c</code>, <code>1</code>, <code>2</code>, <code>3</code>.</p> <p>You can also use the <code>length</code> and <code>uppercase</code> arguments with <code>random.any()</code>.</p> <p>For example: <code>${random.any(chars=\"xyz\", length=5, uppercase=true)}</code> will generate a 5-character uppercase value from the set of characters <code>x</code>, <code>y</code>, <code>z</code>.</p>"},{"location":"templates/#items-in-a-store","title":"Items in a Store","text":"<p>You can use items from a Store, including data captured previously, or set by a script.</p> <p>Syntax: <code>stores.&lt;store name&gt;.&lt;item name&gt;</code></p> <p>For example, a template file might look like this:</p> <pre><code>{\n  \"userName\": \"${stores.testStore.person}\"\n}\n</code></pre> <p>The placeholder <code>${stores.testStore.person}</code> refers to an item named 'person' in the store named 'testStore'.</p> <p>Learn more about stores.</p>"},{"location":"templates/#system-and-server-values","title":"System and server values","text":"<p>These expressions provide access to Imposter system values, such as the listen port or the server URL.</p> <p>Valid system/server properties:</p> Syntax Example Example value <code>system.server.port</code> <code>${system.server.port}</code> <code>\"8080\"</code> <code>system.server.url</code> <code>${system.server.url}</code> <code>\"http://localhost:8080\"</code>"},{"location":"templates/#script-driven-templates","title":"Script-driven templates","text":"<p>When you are using scripting to control mock behaviour, you can use the <code>template()</code> method, as follows:</p> <pre><code>respond().withFile('example-template.json').template();\n</code></pre> <p>As with the configuration-driven approach described above, your template includes placeholders.</p> <p>A common pattern is to use a script to retrieve items from a store, or generate values dynamically and set them in a store, for use in a template.</p>"},{"location":"templates/#using-jsonpath-in-placeholders","title":"Using JsonPath in placeholders","text":"<p>You can use a JsonPath expression to query an object when using a placeholder.</p> <p>See the template queries page for more details.</p>"},{"location":"templates/#templating-performance","title":"Templating performance","text":"<p>Templating incurs a performance penalty, but is often faster than dynamically generating large objects using scripts, so is generally a better tradeoff when dynamic responses are required.</p> <p>Template files are cached in memory once read from disk, so they do not incur as high an I/O cost from storage on subsequent requests.</p>"},{"location":"templates/#examples","title":"Examples","text":"<ul> <li>response-template</li> </ul>"},{"location":"tips_tricks/","title":"Tips and tricks","text":"<p>This section provides more ideas on how to use Imposter as part of your project.</p>"},{"location":"tips_tricks/#waiting-for-the-server-to-be-ready","title":"Waiting for the server to be ready","text":"<p>The mock server exposes an endpoint at <code>/system/status</code> that will return HTTP 200 when the mock server is up and running. You can use this in your tests to know when the mock server is ready.</p>"},{"location":"tips_tricks/#script-logging","title":"Script logging","text":"<p>You can use the <code>logger</code> object within your scripts, which supports levels such as <code>info</code>, <code>debug</code> etc.</p>"},{"location":"tips_tricks/#pinning-a-version","title":"Pinning a version","text":"<p>You can pin the version of Imposter so you always get the same engine version.</p> <p>You can do this in a few ways using the CLI:</p> <ol> <li>Pass the <code>--version x.y.z</code> argument to <code>imposter up</code>, or</li> <li>Set <code>version: x.y.z</code> in an <code>.imposter.yaml</code> file in the config directory, or</li> <li>Set <code>version: x.y.z</code> in your <code>$HOME/imposter/config.yaml</code> file</li> </ol> <p>If you're using the Imposter GitHub Actions in your CI/CD workflow, you can:</p> <ol> <li>Set the <code>version</code> input to the <code>imposter-github-action/start-mocks</code> action, or</li> <li>Set <code>version: x.y.z</code> in an <code>.imposter.yaml</code> file in the config directory</li> </ol>"},{"location":"tips_tricks/#using-a-local-imposter-jar-with-the-cli","title":"Using a local Imposter JAR with the CLI","text":"<p>You can use a local Imposter JAR file with the CLI. </p> <ol> <li>Download the JAR file from the releases page.</li> <li>Set the <code>IMPOSTER_JVM_JARFILE</code> environment variable to the local path of the JAR file.</li> <li>Start Imposter using the CLI, specifying the <code>jvm</code> engine type.</li> </ol> <p>For example:</p> <pre><code>export IMPOSTER_JVM_JARFILE=/path/to/imposter.jar\nimposter up -t jvm\n</code></pre>"},{"location":"tips_tricks/#standalone-mocks","title":"Standalone mocks","text":"<p>You can make use of Imposter mocks as standalone Docker containers.</p> <p>See bundling configuration for details on how to bundle your configuration and mock data into a Docker image.</p>"},{"location":"tips_tricks/#testcontainers-integration","title":"Testcontainers integration","text":"<p>You can make use of Imposter mocks in your JUnit tests using the excellent testcontainers library. This will enable your mocks to start/stop before/after your tests run.</p> <p>Here's a simple overview:</p> <ol> <li>Follow the testcontainers 'getting started' documentation for your project.</li> <li>Add your mock configuration and mock data to your project (e.g. under <code>src/test/resources</code>).</li> <li>Add a testcontainers <code>GenericContainer</code> class rule to your JUnit test, for one of the Imposter Docker images (see Docker section).</li> <li>Configure your <code>GenericContainer</code> to mount the directory containing your configuration and data (e.g. <code>src/test/resources</code>) to <code>/opt/imposter/config</code>.</li> <li>Configure your <code>GenericContainer</code> to wait for the <code>/system/status</code> HTTP endpoint to be accessible so your tests don't start before the mock is ready.</li> </ol> <p>Now, when you run your test, your custom mock container will start, load your configuration and mock data, ready for your test methods to use it!</p>"},{"location":"tips_tricks/#set-openapi-spec-base-path","title":"Set OpenAPI spec base path","text":"<p>Set the environment variable <code>IMPOSTER_OPENAPI_SPEC_PATH_PREFIX</code>, to override the default <code>/_spec</code> prefix.</p> <p>For example:</p> <pre><code>IMPOSTER_OPENAPI_SPEC_PATH_PREFIX=\"/api/core-mock/v1/_spec\"\n</code></pre> <p>...will make the spec UI accessible at http://localhost:8080/api/core-mock/v1/_spec/</p>"},{"location":"tls_ssl/","title":"TLS/SSL","text":"<p>You can run Imposter with HTTPS enabled. To do this, enable the TLS option and provide keystore options.</p> <p>Note: unless you explicitly override the listen port (<code>--listenPort</code>), enabling TLS will change the listen port to 8443.</p>"},{"location":"tls_ssl/#example","title":"Example","text":"<pre><code>java -jar distro/all/build/libs/imposter-all.jar \\\n        --plugin rest \\\n        --configDir /path/to/config \\\n        --tlsEnabled \\\n        --keystorePath ./server/src/main/resources/keystore/ssl.jks \\\n        --keystorePassword password\n</code></pre> <p>Note: This example uses the self-signed certificate for TLS/SSL found in the source repository. You can, of course, use your own keystore instead. If you need to access the keys or certificate from this example, the keystore is located at <code>server/src/main/resources/keystore</code> and uses the secure password 'password'.</p>"},{"location":"tls_ssl/#a-note-on-certificates","title":"A note on certificates","text":"<p>SSL certificates must match the domain where you\u2019re hosting an application, e.g. https://example.com would need a certificate issued for the example.com domain.</p> <p>Normally, you would obtain a signed certificate for a given domain via a third party provider. Certificates signed by a public certificate authority (CA) will generally be trusted by client applications as the CA is trusted by your system.</p> <p>If you generate a certificate yourself, or use the test one in this project, this is known as a self-signed certificate. Self-signed certificates are untrusted and you usually have to configure your client to accept them explicitly, such as via a trust store or other JVM-wide SSL configuration.</p>"},{"location":"usage/","title":"Usage (command line arguments and environment variables)","text":""},{"location":"usage/#command-line-arguments","title":"Command line arguments","text":"<p>Some options can be controlled using command line arguments.</p> <ul> <li>If you are using the CLI, see this documentation for a list of command line arguments.</li> <li>If you are using the JAR approach, see this documentation.</li> </ul>"},{"location":"usage/#environment-variables","title":"Environment variables","text":"<p>See environment variables for a list of all environment variables.</p>"},{"location":"usage/#setting-environment-variables-using-a-file","title":"Setting environment variables using a file","text":"<p>You can use an environment file ('envfile') to pass environment variables to Imposter. To do this, add a file named <code>.env</code> adjacent to your configuration files, for example:</p> <pre><code>$ ls\n.env\nimposter-config.yaml\n\n$ cat .env\nIMPOSTER_LOG_LEVEL=info\nOTHER_ENV_VAR=example\n</code></pre>"},{"location":"usage_jar/","title":"Usage jar","text":""},{"location":"usage_jar/#jar-command-line-arguments","title":"JAR command line arguments","text":"<p>When you are using the JAR approach, some options can be controlled using command line arguments.</p> <p>Note If you are using the CLI, see this documentation for a list of command line arguments.</p>"},{"location":"usage_jar/#available-arguments","title":"Available arguments","text":"<p>The following command line arguments can be used:</p> <pre><code> --configDir (-c) VAL   : Directory containing mock configuration files\n --help (-h)            : Display usage only\n --host (-b) VAL        : Bind host\n --keystorePassword VAL : Password for the keystore (default: password)\n --keystorePath VAL     : Path to the keystore (default: classpath:/keystore/ssl.jks)\n --listenPort (-l) N    : Listen port (default: 8080)\n --plugin (-p) VAL      : Plugin name (e.g. rest) or fully qualified class\n --pluginArg VAL        : A plugin argument (key=value)\n --serverUrl (-u) VAL   : Explicitly set the server address\n --tlsEnabled (-t)      : Whether TLS (HTTPS) is enabled (requires keystore to be configured) (default: false)\n --version (-v)         : Print version and exit\n</code></pre>"},{"location":"usage_jar/#server-url","title":"Server URL","text":"<p>For some responses, such as from the SFDC plugin, Imposter uses the 'server URL', which is computed automatically from the <code>host</code> and <code>listenPort</code> command line arguments. If this is not the URL you wish to use, you can override this with the <code>serverUrl</code> command line argument.</p>"},{"location":"wiremock_plugin/","title":"WireMock plugin","text":"<ul> <li>Plugin name: <code>wiremock</code></li> <li>Plugin class: <code>io.gatehill.imposter.plugin.wiremock.WiremockPluginImpl</code></li> </ul>"},{"location":"wiremock_plugin/#features","title":"Features","text":"<ul> <li>supports setting request headers, query parameters, and HTTP method.</li> <li>supports response status code, response headers and response files (including templating).</li> <li>supports <code>body</code> responses.</li> <li>supports <code>jsonBody</code> responses.</li> <li>supports multiple body patterns.</li> <li>partial support for faults.</li> <li>supports plain (root object) and multiple (root array) mappings files.</li> </ul>"},{"location":"wiremock_plugin/#install-plugin","title":"Install plugin","text":""},{"location":"wiremock_plugin/#option-1-using-the-cli","title":"Option 1: Using the CLI","text":"<p>To use this plugin, install it with the Imposter CLI:</p> <pre><code>imposter plugin install -d wiremock\n</code></pre> <p>This will install the plugin version matching the current engine version used by the CLI. The next time you run <code>imposter up</code>, the plugin will be available.</p>"},{"location":"wiremock_plugin/#option-2-install-the-plugin-manually","title":"Option 2: Install the plugin manually","text":"<p>To use this plugin, download the <code>imposter-plugin-wiremock.jar</code> JAR file from the Releases page.</p> <p>Enable it with the following environment variables:</p> <pre><code>IMPOSTER_PLUGIN_DIR=\"/path/to/dir/containing/plugin\"\n</code></pre>"},{"location":"wiremock_plugin/#using-the-plugin","title":"Using the plugin","text":"<p>Read the Configuration section to understand how to configure Imposter.</p>"},{"location":"wiremock_plugin/#example","title":"Example","text":"<p>For working examples, see WireMock examples.</p> <p>Let's assume your configuration is in a folder named <code>wiremock-simple</code>.</p> <p>CLI example:</p> <pre><code>imposter up ./wiremock-simple --engine-type docker-all\n</code></pre> <p>Docker example:</p> <pre><code>docker run -ti -p 8080:8080 \\\n    -v $PWD/wiremock-simple:/opt/imposter/config \\\n    outofcoffee/imposter-all\n</code></pre> <p>Standalone Java example:</p> <pre><code>java -jar distro/all/build/libs/imposter-all.jar \\\n    --configDir ./wiremock-simple\n</code></pre> <p>This starts a mock server using the WireMock plugin. Responses are served based on the mappings files inside the <code>wiremock-simple/mappings</code> folder and the templated response files in the <code>wiremock-simple/__files</code> folder.</p> <p>Using the example above, Imposter will parse the WireMock mappings files and create an HTTP mock on http://localhost:8080/.</p>"},{"location":"wiremock_plugin/#testing-the-mock","title":"Testing the mock","text":"<pre><code>curl http://localhost:8080/example1 -H 'Accept: application/json'\n\n{ \"id\": 2, \"name\": \"Dog\" }\n</code></pre>"},{"location":"wiremock_plugin/#additional-script-context-objects","title":"Additional script context objects","text":"<p>There are no additional script context objects available.</p>"},{"location":"wiremock_plugin/#further-reading","title":"Further reading","text":"<ul> <li>WireMock examples</li> </ul>"},{"location":"examples/","title":"Index","text":"<p>See examples.</p>"},{"location":"external/short_description/","title":"Short description (&lt;1000 characters)","text":"<p>Imposter is a system that runs live, interactive mocks in place of real systems. Turn an OpenAPI file into a mock API for dev or QA. Run standalone mock servers, or embed mocks within your tests.</p> <p>Validate HTTP requests to ensure they match the OpenAPI specification. Serve response examples embedded in the specification. Explore mock endpoints using the interactive API sandbox based on Swagger UI.</p> <p>Imposter supports custom responses, headers, status codes etc. based on path, querystring, request headers, request body and more.Responses can be templated - that is, a file or string containing placeholders, which are replaced with values at runtime.</p> <p>You can match resources to requests using attributes such as the HTTP method, path, query string, headers or body (both JSON and XML supported). Also supports script-driven responses for maximum control, in either JavaScript or Groovy.</p> <p>Imposter also allows you to capture elements of the request, so you can retrieve them later.</p>"},{"location":"hack/","title":"Developing Imposter","text":""},{"location":"hack/#convenience-script","title":"Convenience script","text":"<p>The script <code>scripts/dev-current.sh</code> is intended for local testing when changing the Impsoter codebase.</p> <p>The script performs the following steps:</p> <ul> <li>builds Imposter from source</li> <li>starts Imposter using Docker or plain JVM</li> <li>enables a specified plugin</li> <li>passes the specified directory as the configuration directory</li> </ul> <p>Usage:</p> <pre><code>dev-current.sh [args]\n\nArguments:\n\n  -m &lt;docker|java&gt;  How to run Imposter, e.g. docker\n  -c config-dir     Path to the Imposter configuration directory\n  [-d distro-name]  The distro name, e.g. openapi\n  [-l log-level]    Logging level, e.g. DEBUG or TRACE\n  [-t run-tests]    Whether to run tests (true or false). Default is true\n  [-z debug-mode]   Whether to enable Java debug mode on port 8000\n</code></pre> <p>Example:</p> <pre><code>$  ./scripts/dev-current.sh -m java -p openapi -c $PWD/examples/openapi/simple\n</code></pre> <p>This starts Imposter in bare JVM mode (no Docker) with the OpenAPI plugin enabled, pointing to the examples directory.</p>"},{"location":"hack/#debugging","title":"Debugging","text":"<p>When started using this script, JVM debug mode is enabled and the debug socket is opened on port 8000.</p>"},{"location":"hack/#test-with-gradle","title":"Test with Gradle","text":"<p>You can run a test using a specific JVM version using Docker and Gradle as follows:</p> <pre><code>docker run -it --rm -u gradle -v \"$PWD\":/home/gradle/project -w /home/gradle/project amd64/gradle:6-jdk11 gradle clean test\n</code></pre>"}]}